{"version":3,"file":"injected.js","sources":["../../src/injected/injected.ts"],"sourcesContent":["/**\n * XHR Interceptor class that observes XMLHttpRequest calls for:\n * - Subtitle requests (timedtext) - notifies Content Script of URL\n *\n * Note: Player API requests (/youtubei/v1/player) are handled by FetchInterceptor\n * since YouTube uses fetch() for these requests.\n *\n * It's completely stateless - just notifies Content Script when relevant requests are detected.\n * The original request is always allowed to proceed normally.\n */\nclass XHRInterceptor {\n  private originalOpen = XMLHttpRequest.prototype.open\n  private originalSend = XMLHttpRequest.prototype.send\n\n  constructor() {\n    this.setupInterceptors()\n  }\n\n  /**\n   * Sets up interceptors for XMLHttpRequest open and send methods\n   */\n  private setupInterceptors(): void {\n    const self = this\n\n    // 拦截 open 方法，记录 URL\n    XMLHttpRequest.prototype.open = function (method: string, url: string | URL, ...args: any[]) {\n      const xhr = this as any\n      const urlString = typeof url === 'string' ? url : url.toString()\n\n      xhr._intercepted = {\n        url: urlString,\n        method,\n        timestamp: Date.now(),\n      }\n\n      return self.originalOpen.apply(this, [method, urlString, ...args] as any)\n    }\n\n    // 拦截 send 方法\n    XMLHttpRequest.prototype.send = function (body?: any): void {\n      const xhr = this as any\n      const url = xhr._intercepted?.url\n\n      // 如果是字幕请求，通知 Content Script（但不阻止原始请求）\n      if (url && self.isSubtitleRequest(url)) {\n        console.log('[XHRInterceptor] Detected timedtext request:', url)\n\n        // 通知 Content Script\n        self.notifyContentScript('SUBTITLE_URL_DETECTED', {\n          url: url,\n          method: xhr._intercepted.method,\n        })\n      }\n\n      // 所有请求都正常发送\n      return self.originalSend.call(this, body)\n    }\n  }\n\n  /**\n   * Check if a URL matches subtitle file patterns\n   * @param url - The URL to check\n   * @returns True if the URL appears to be a subtitle request\n   */\n  private isSubtitleRequest(url: string): boolean {\n    const subtitlePatterns = [\n      /timedtext/,\n      /\\.vtt(\\?|$)/,\n      /\\.srt(\\?|$)/,\n      /subtitles?/,\n      /captions?/,\n      /\\.ttml(\\?|$)/,\n    ]\n\n    return subtitlePatterns.some((pattern) => pattern.test(url))\n  }\n\n  /**\n   * Sends a message to the content script via postMessage\n   * @param type - The message type to send\n   * @param data - The data payload to include in the message\n   */\n  private notifyContentScript(type: string, data: any): void {\n    window.postMessage(\n      {\n        source: 'XHR_INTERCEPTED',\n        type,\n        data,\n        timestamp: Date.now(),\n      },\n      '*',\n    )\n  }\n}\n\n/**\n * Fetch Interceptor class that observes fetch() calls for Player API requests.\n * YouTube uses fetch() for /youtubei/v1/player during SPA navigation.\n */\nclass FetchInterceptor {\n  private originalFetch = window.fetch.bind(window)\n\n  constructor() {\n    this.setupInterceptor()\n  }\n\n  private setupInterceptor(): void {\n    const self = this\n\n    window.fetch = async function (\n      input: RequestInfo | URL,\n      init?: RequestInit,\n    ): Promise<Response> {\n      const url = typeof input === 'string' ? input : input instanceof URL ? input.href : input.url\n\n      // Call original fetch first\n      const response = await self.originalFetch(input, init)\n\n      // Check if this is a Player API request\n      if (self.isPlayerApiRequest(url)) {\n        // Clone the response so we can read it without consuming the original\n        const clonedResponse = response.clone()\n\n        // Process asynchronously to not block the response\n        self.handlePlayerApiResponse(clonedResponse).catch((error) => {\n          console.error('[FetchInterceptor] Failed to process player API response:', error)\n        })\n      }\n\n      return response\n    }\n  }\n\n  private isPlayerApiRequest(url: string): boolean {\n    return /\\/youtubei\\/v1\\/player/.test(url)\n  }\n\n  private async handlePlayerApiResponse(response: Response): Promise<void> {\n    try {\n      if (!response.ok) return\n\n      const data = await response.json()\n      if (!data.videoDetails?.videoId) return\n\n      window.postMessage(\n        {\n          source: 'INJECTED_SCRIPT',\n          type: 'VIDEO_METADATA',\n          data: {\n            playerResponse: data,\n            initialData: null,\n          },\n          timestamp: Date.now(),\n        },\n        '*',\n      )\n    } catch (error) {\n      console.error('[FetchInterceptor] Failed to parse Player API response:', error)\n    }\n  }\n}\n\n/**\n * Video Metadata Extractor class that reads YouTube's internal data objects\n * Responds to requests from Content Script and sends back the data\n */\nclass VideoMetadataExtractor {\n  constructor() {\n    this.setupMessageListener()\n    // Also send initial data if available\n    this.sendInitialDataIfAvailable()\n  }\n\n  /**\n   * Listen for requests from Content Script\n   */\n  private setupMessageListener(): void {\n    window.addEventListener('message', (event) => {\n      if (event.source !== window) return\n      if (event.data?.source === 'CONTENT_SCRIPT' && event.data?.type === 'GET_VIDEO_METADATA') {\n        this.sendVideoMetadata()\n      }\n    })\n  }\n\n  /**\n   * Send initial data if ytInitialPlayerResponse is already available\n   * Uses a small delay to ensure YouTube has finished setting up its data\n   */\n  private sendInitialDataIfAvailable(): void {\n    // Check immediately\n    if (this.hasYouTubeData()) {\n      this.sendVideoMetadata()\n      return\n    }\n\n    // Retry a few times with increasing delays\n    const delays = [100, 500, 1000, 2000]\n    delays.forEach((delay) => {\n      setTimeout(() => {\n        if (this.hasYouTubeData()) {\n          this.sendVideoMetadata()\n        }\n      }, delay)\n    })\n  }\n\n  /**\n   * Check if YouTube data is available\n   */\n  private hasYouTubeData(): boolean {\n    const win = window as any\n    return !!(win.ytInitialPlayerResponse || win.ytInitialData)\n  }\n\n  /**\n   * Extract and send video metadata to Content Script\n   */\n  private sendVideoMetadata(): void {\n    const win = window as any\n\n    window.postMessage(\n      {\n        source: 'INJECTED_SCRIPT',\n        type: 'VIDEO_METADATA',\n        data: {\n          playerResponse: win.ytInitialPlayerResponse || null,\n          initialData: win.ytInitialData || null,\n        },\n        timestamp: Date.now(),\n      },\n      '*',\n    )\n  }\n}\n\n/**\n * Initialize all interceptors and extractors\n * Uses the `_xhrInterceptorInitialized` variable to ensure single initialization\n */\n;(() => {\n  if (!(window as any)._xhrInterceptorInitialized) {\n    ;(window as any)._xhrInterceptorInitialized = true\n    new XHRInterceptor()\n    new FetchInterceptor()\n    new VideoMetadataExtractor()\n    console.log(\n      '[Interceptor] XHR/Fetch Interceptors and Video Metadata Extractor initialized in page context',\n    )\n  }\n})()\n"],"names":[],"mappings":"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"}