{"version":3,"file":"chunk--DVCTphW.js","sources":["../../src/context.ts","../../src/i18n/index.ts","../../src/tools/messageUtils.ts","../../src/tools/clientBridge.ts","../../src/tools/collectionBridge.ts"],"sourcesContent":["/**\n * Global context and configuration for Moki extension.\n *\n * Defines supported languages and provides utility functions\n * for language name lookups using i18n.\n */\n\nimport { t } from './i18n'\n\n// ============================================================================\n// Supported Languages\n// ============================================================================\n\n/**\n * Supported language codes for native language and target language.\n * These codes are used for API calls (e.g., translation, NLP).\n *\n * Format: BCP 47 language tags (e.g., 'zh-CN', 'en', 'ja')\n */\nexport const SUPPORTED_LANGUAGES = ['en', 'zh-CN', 'zh-TW', 'ja', 'ko', 'es', 'fr', 'de'] as const\n\nexport type SupportedLanguageCode = (typeof SUPPORTED_LANGUAGES)[number]\n\n/**\n * Supported locale codes for interface language.\n * These codes are used for i18n (Chrome extension _locales format).\n *\n * Format: underscore-separated (e.g., 'zh_CN', 'en', 'ja')\n */\nexport const SUPPORTED_LOCALES = ['en', 'zh_CN', 'zh_TW', 'ja', 'ko', 'es', 'fr', 'de'] as const\n\nexport type SupportedLocaleCode = (typeof SUPPORTED_LOCALES)[number]\n\n/**\n * Check if a locale code is supported.\n * Type-safe version of SUPPORTED_LOCALES.includes()\n */\nexport function isSupportedLocale(locale: string): locale is SupportedLocaleCode {\n  return (SUPPORTED_LOCALES as readonly string[]).includes(locale)\n}\n\n// ============================================================================\n// Language Name Utilities\n// ============================================================================\n\n/**\n * Convert language code to i18n message key.\n * e.g., 'zh-CN' -> 'languages_zhCN', 'en' -> 'languages_en'\n */\nfunction languageCodeToI18nKey(code: string): string {\n  // Remove hyphen and create key: 'zh-CN' -> 'zhCN', 'en' -> 'en'\n  const normalizedCode = code.replace('-', '')\n  return `languages_${normalizedCode}`\n}\n\n/**\n * Get localized language name from language code.\n * Uses i18n to get the name in the user's interface language.\n *\n * @param code - Language code (e.g., 'zh-CN', 'en', 'ja')\n * @returns Localized language name (e.g., '简体中文', 'English', '日本語')\n */\nexport function getLanguageName(code: string): string {\n  const key = languageCodeToI18nKey(code)\n  const name = t(key)\n  // If translation not found, return the code itself\n  return name !== key ? name : code\n}\n\n/**\n * Convert locale code to language code.\n * e.g., 'zh_CN' -> 'zh-CN', 'en' -> 'en'\n */\nexport function localeToLanguageCode(locale: string): string {\n  return locale.replace('_', '-')\n}\n\n/**\n * Convert language code to locale code.\n * e.g., 'zh-CN' -> 'zh_CN', 'en' -> 'en'\n */\nexport function languageCodeToLocale(code: string): string {\n  return code.replace('-', '_')\n}\n","/**\n * i18n utility module for Chrome Extension\n * Supports custom interface language selection\n */\n\nimport { SUPPORTED_LOCALES, isSupportedLocale } from '../context'\n\ntype Messages = Record<string, { message: string; description?: string }>\ntype MessagesCache = Record<string, Messages>\n\nconst DEFAULT_LOCALE = 'en'\nconst STORAGE_KEY = 'interfaceLanguage'\n\n// Cache for all locale messages\nlet messagesCache: MessagesCache = {}\nlet currentLocale: string = DEFAULT_LOCALE\nlet browserLocale: string = DEFAULT_LOCALE // Browser's UI language (for unauthenticated state)\n\n/**\n * Initialize i18n system by loading all locale files\n */\nexport async function initI18n(): Promise<void> {\n  // Determine browser's UI language (for unauthenticated state)\n  const browserLang = chrome.i18n.getUILanguage()\n  const normalizedBrowserLang = normalizeLocale(browserLang)\n  browserLocale = isSupportedLocale(normalizedBrowserLang) ? normalizedBrowserLang : DEFAULT_LOCALE\n\n  // Get user's preferred interface language from storage\n  const stored = await chrome.storage.sync.get([STORAGE_KEY])\n  const userLocale = stored[STORAGE_KEY]\n\n  // Determine which locale to use for authenticated state\n  if (userLocale && isSupportedLocale(userLocale)) {\n    currentLocale = userLocale\n  } else {\n    // Fallback to browser language\n    currentLocale = browserLocale\n  }\n\n  // Load messages for both browser locale and current locale\n  await Promise.all([loadMessages(browserLocale), loadMessages(currentLocale)])\n}\n\n/**\n * Load messages for a specific locale\n */\nasync function loadMessages(locale: string): Promise<void> {\n  if (messagesCache[locale]) {\n    return // Already loaded\n  }\n\n  try {\n    const url = chrome.runtime.getURL(`_locales/${locale}/messages.json`)\n    const response = await fetch(url)\n    const messages = await response.json()\n    messagesCache[locale] = messages\n  } catch (error) {\n    console.error(`[i18n] Failed to load messages for locale: ${locale}`, error)\n    // Fallback to default locale\n    if (locale !== DEFAULT_LOCALE) {\n      await loadMessages(DEFAULT_LOCALE)\n    }\n  }\n}\n\n/**\n * Normalize locale code (e.g., \"zh-CN\" -> \"zh_CN\")\n */\nfunction normalizeLocale(locale: string): string {\n  return locale.replace('-', '_')\n}\n\n/**\n * Get internationalized text (uses user's interface language setting)\n * @param key - i18n message key (e.g., \"popup_title\")\n * @param substitutions - Optional placeholder substitutions\n * @returns Translated message text\n */\nexport function t(key: string, substitutions?: string | string[]): string {\n  const messages = messagesCache[currentLocale] || messagesCache[DEFAULT_LOCALE]\n\n  if (!messages) {\n    console.warn(\n      `[i18n] No messages loaded for locale: ${currentLocale}, cache keys:`,\n      Object.keys(messagesCache),\n    )\n    return key\n  }\n\n  if (!messages[key]) {\n    console.warn(\n      `[i18n] Missing translation key: ${key} for locale: ${currentLocale}`,\n      `Available keys: ${Object.keys(messages).length}`,\n    )\n    return key // Return key itself for debugging\n  }\n\n  let message = messages[key].message\n\n  // Handle substitutions\n  if (substitutions) {\n    const subs = Array.isArray(substitutions) ? substitutions : [substitutions]\n    subs.forEach((sub, index) => {\n      message = message.replace(`$${index + 1}`, sub)\n    })\n  }\n\n  return message\n}\n\n/**\n * Get internationalized text using browser's UI language (for unauthenticated state)\n * Use this in login/register screens and unauthenticated components\n * @param key - i18n message key (e.g., \"auth_login_button\")\n * @param substitutions - Optional placeholder substitutions\n * @returns Translated message text in browser's language\n */\nexport function tBrowser(key: string, substitutions?: string | string[]): string {\n  const messages = messagesCache[browserLocale] || messagesCache[DEFAULT_LOCALE]\n\n  if (!messages) {\n    console.warn(\n      `[i18n] No messages loaded for browser locale: ${browserLocale}, cache keys:`,\n      Object.keys(messagesCache),\n    )\n    return key\n  }\n\n  if (!messages[key]) {\n    console.warn(\n      `[i18n] Missing translation key: ${key} for browser locale: ${browserLocale}`,\n      `Available keys: ${Object.keys(messages).length}`,\n    )\n    return key\n  }\n\n  let message = messages[key].message\n\n  // Handle substitutions\n  if (substitutions) {\n    const subs = Array.isArray(substitutions) ? substitutions : [substitutions]\n    subs.forEach((sub, index) => {\n      message = message.replace(`$${index + 1}`, sub)\n    })\n  }\n\n  return message\n}\n\n/**\n * Get current interface language\n * @returns Language code (e.g., \"zh_CN\", \"en\", \"ja\")\n */\nexport function getCurrentLocale(): string {\n  return currentLocale\n}\n\n/**\n * Set interface language and reload messages\n * @param locale - Language code (e.g., \"zh_CN\", \"en\", \"ja\")\n */\nexport async function setInterfaceLanguage(locale: string): Promise<void> {\n  if (!isSupportedLocale(locale)) {\n    console.error(`[i18n] Unsupported locale: ${locale}`)\n    return\n  }\n\n  currentLocale = locale\n  await chrome.storage.sync.set({ [STORAGE_KEY]: locale })\n  await loadMessages(locale)\n}\n\n/**\n * Get list of supported locales\n */\nexport function getSupportedLocales(): string[] {\n  return [...SUPPORTED_LOCALES]\n}\n\n/**\n * Get current browser UI language\n * @returns Language code (e.g., \"zh-CN\", \"en\", \"ja\")\n */\nexport function getBrowserLanguage(): string {\n  return chrome.i18n.getUILanguage()\n}\n","/**\n * Message utilities for Chrome extension communication\n *\n * Provides two patterns for sending messages to Background Service:\n * 1. sendMessageWithResponse - Request-Response pattern with timeout\n * 2. sendMessageFireAndForget - Fire-and-Forget pattern (no response expected)\n */\n\nimport { MessageSource, MessageType } from '../types/messages'\n\nconst DEFAULT_TIMEOUT = 10000 // 10 seconds\n\n/**\n * Send a message to Background Service and wait for response with timeout.\n *\n * Use this for operations that require a response:\n * - Authentication checks (CHECK_AUTH)\n * - Data retrieval (GET_SUBTITLE_DATA)\n * - Login/Logout operations\n *\n * @param source - Message source identifier\n * @param type - Message type\n * @param data - Optional data payload\n * @param timeout - Timeout in milliseconds (default: 10000ms)\n * @returns Promise resolving to the response\n * @throws Error if timeout or chrome.runtime.lastError\n */\nexport function sendMessageWithResponse<T>(\n  source: MessageSource,\n  type: MessageType,\n  data: Record<string, unknown> = {},\n  timeout: number = DEFAULT_TIMEOUT,\n): Promise<T> {\n  return new Promise((resolve, reject) => {\n    const timer = setTimeout(() => {\n      reject(new Error(`Message ${type} timed out after ${timeout}ms`))\n    }, timeout)\n\n    chrome.runtime.sendMessage(\n      {\n        source,\n        type,\n        data,\n        timestamp: Date.now(),\n      },\n      (response) => {\n        clearTimeout(timer)\n\n        if (chrome.runtime.lastError) {\n          reject(new Error(chrome.runtime.lastError.message || 'Unknown error'))\n        } else {\n          resolve(response)\n        }\n      },\n    )\n  })\n}\n\n/**\n * Send a message to Background Service without waiting for response.\n *\n * Use this for notifications that don't require acknowledgment:\n * - INIT_BACKGROUND\n * - VIDEO_CURRENT_TIMESTAMP\n * - FINISH_TRANSLATE\n * - OPEN_POPUP\n *\n * @param source - Message source identifier\n * @param type - Message type\n * @param data - Optional data payload\n */\nexport function sendMessageFireAndForget(\n  source: MessageSource,\n  type: MessageType,\n  data: Record<string, unknown> = {},\n): void {\n  chrome.runtime.sendMessage({\n    source,\n    type,\n    data,\n    timestamp: Date.now(),\n  })\n}\n","/**\n * Client Bridge - Proxy API calls through Background Service\n *\n * This module provides a way to call APIClient methods from Popup and\n * Content Script contexts through the Background Service, ensuring\n * single source of truth for token management.\n *\n * Usage:\n *   import { callAPI } from '../tools/clientBridge'\n *   const collections = await callAPI('getVideoCollections', { skip: 0, limit: 20 })\n */\n\nimport { sendMessageWithResponse } from './messageUtils'\nimport { MessageSource, MessageType } from '../types/messages'\n\n// Define the methods that can be called through the bridge\n// These are the public async methods of APIClient\nexport type BridgeableMethods =\n  // Video Collections\n  | 'getVideoCollections'\n  | 'getVideoCollection'\n  | 'deleteVideoCollection'\n  | 'createVideoCollection'\n  // Video Views\n  | 'listVideoViews'\n  | 'getVideoView'\n  | 'addVideoView'\n  // Dictionary\n  | 'lookupWord'\n  | 'lookupEntry'\n  // NLP\n  | 'detectLanguage'\n  | 'analyzeText'\n\ninterface APICallResponse<T> {\n  success: boolean\n  data?: T\n  error?: string\n}\n\n/**\n * Call an APIClient method through the Background Service.\n * Works from both Popup and Content Script contexts.\n *\n * @param method - The APIClient method name to call\n * @param args - Arguments to pass to the method (spread as individual args)\n * @returns The result from the API call\n * @throws Error if the API call fails\n *\n * @example\n * // Single object argument\n * const collections = await callAPI('getVideoCollections', { skip: 0, limit: 20 })\n *\n * // Multiple arguments\n * const entry = await callAPI('lookupEntry', 'run', 'en', 'zh-CN')\n *\n * // No arguments\n * const user = await callAPI('getCurrentUser')\n */\nexport async function callAPI<T>(method: BridgeableMethods, ...args: unknown[]): Promise<T> {\n  // Determine the source based on context\n  // Content scripts and popup both use chrome.runtime.sendMessage\n  // We use CONTENT_SCRIPT as a generic source for non-background contexts\n  const source = MessageSource.CONTENT_SCRIPT\n\n  const response = await sendMessageWithResponse<APICallResponse<T>>(source, MessageType.API_CALL, {\n    method,\n    args,\n  })\n\n  if (!response?.success) {\n    throw new Error(response?.error || `API call '${method}' failed`)\n  }\n\n  return response.data as T\n}\n","import { VideoCollectionCreateRequest, VideoCollectionResponse } from './client'\nimport { CollectionInfo, MessageType, MessageSource } from '../types/messages'\nimport { sendMessageWithResponse } from './messageUtils'\n\n/**\n * CollectionBridge - Bridge layer for collection operations\n *\n * Provides a clean API for Content Script and Popup to interact with\n * CollectionManager in Background Service via message passing.\n *\n * All methods are async and handle the message passing transparently.\n *\n * Note: Most methods use CONTENT_SCRIPT as source, but removeCollection\n * supports both CONTENT_SCRIPT and POPUP sources.\n */\nexport const CollectionBridge = {\n  /**\n   * Load collections for a specific video.\n   *\n   * @param videoViewId - Video view ID\n   * @param sourceLang - Source language code\n   * @returns Array of CollectionInfo\n   */\n  async loadCollections(videoViewId: number, sourceLang: string): Promise<CollectionInfo[]> {\n    const response = await sendMessageWithResponse<{ collections: CollectionInfo[] }>(\n      MessageSource.CONTENT_SCRIPT,\n      MessageType.COLLECTION_LOAD,\n      { videoViewId, sourceLang },\n    )\n    return response.collections\n  },\n\n  /**\n   * Remove a collection.\n   * Can be called with or without videoViewId:\n   * - With videoViewId: faster lookup in specific cache\n   * - Without videoViewId: searches all caches (for Popup use)\n   *\n   * @param collectionId - Collection UUID to remove\n   * @param videoViewId - Optional video view ID for faster lookup\n   * @param source - Message source (defaults to CONTENT_SCRIPT, use POPUP for Popup)\n   */\n  async removeCollection(\n    collectionId: string,\n    videoViewId?: number,\n    source: MessageSource = MessageSource.CONTENT_SCRIPT,\n  ): Promise<void> {\n    await sendMessageWithResponse<{ success: boolean }>(source, MessageType.COLLECTION_REMOVE, {\n      videoViewId: videoViewId ?? 0, // 0 means search all caches\n      collectionId,\n    })\n  },\n\n  /**\n   * Check if a word is collected.\n   *\n   * @param videoViewId - Video view ID\n   * @param word - Word to check\n   * @param segmentBegin - Segment start time (ms)\n   * @returns true if collected\n   */\n  async isWordCollected(videoViewId: number, word: string, segmentBegin: number): Promise<boolean> {\n    const response = await sendMessageWithResponse<{ collected: boolean }>(\n      MessageSource.CONTENT_SCRIPT,\n      MessageType.COLLECTION_CHECK,\n      { videoViewId, word, segmentBegin },\n    )\n    return response.collected\n  },\n\n  /**\n   * Get collection ID for a word (used for unfavorite).\n   *\n   * @param videoViewId - Video view ID\n   * @param word - Word to look up\n   * @param segmentBegin - Segment start time (ms)\n   * @returns Collection ID or null\n   */\n  async getCollectionId(\n    videoViewId: number,\n    word: string,\n    segmentBegin: number,\n  ): Promise<string | null> {\n    const response = await sendMessageWithResponse<{ collectionId: string | null }>(\n      MessageSource.CONTENT_SCRIPT,\n      MessageType.COLLECTION_CHECK,\n      { videoViewId, word, segmentBegin, returnId: true },\n    )\n    return response.collectionId\n  },\n\n  /**\n   * Get collected lemmas for sidebar highlighting.\n   *\n   * @param videoViewId - Video view ID\n   * @returns Set of lowercase lemmas\n   */\n  async getCollectedLemmas(videoViewId: number): Promise<Set<string>> {\n    const response = await sendMessageWithResponse<{ lemmas: string[] }>(\n      MessageSource.CONTENT_SCRIPT,\n      MessageType.COLLECTION_GET_LEMMAS,\n      { videoViewId },\n    )\n    return new Set(response.lemmas)\n  },\n\n  /**\n   * Create a new collection.\n   * Calls API via Background, updates cache, and broadcasts to all tabs.\n   *\n   * @param request - Video collection create request\n   * @returns Created collection response\n   */\n  async createCollection(request: VideoCollectionCreateRequest): Promise<VideoCollectionResponse> {\n    const response = await sendMessageWithResponse<{\n      success: boolean\n      collection?: VideoCollectionResponse\n      error?: string\n    }>(MessageSource.CONTENT_SCRIPT, MessageType.COLLECTION_CREATE, { request })\n\n    if (!response.success || !response.collection) {\n      throw new Error(response.error || 'Failed to create collection')\n    }\n    return response.collection\n  },\n}\n"],"names":[],"mappings":"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"}