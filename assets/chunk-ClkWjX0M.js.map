{"version":3,"file":"chunk-ClkWjX0M.js","sources":["../../src/tools/client.ts","../../src/background/authHandler.ts","../../src/background/collectionHandler.ts","../../src/background/collectionManager.ts","../../src/background/settingsHandler.ts","../../src/background/externalMessageHandler.ts","../../src/background/index.ts"],"sourcesContent":["import { Logger } from '../tools/logger'\n\n// ============================================================================\n// Type Definitions - Translation API\n// ============================================================================\n\nexport interface TranslateRequest {\n  segments: string[]\n  source_lng?: string\n  target_lng?: string\n  prompt?: string | null\n}\n\nexport interface TranslateResponse {\n  segments: string[]\n  count: number\n}\n\n// ============================================================================\n// Type Definitions - Dictionary API\n// ============================================================================\n\nexport interface LookupRequest {\n  word: string\n  context: string\n  native_lng?: string\n}\n\nexport interface Definition {\n  meaning: string\n}\n\n// Entry Lookup Types (Database Query)\nexport interface FormDetail {\n  form: string\n  tags: string[]\n}\n\nexport interface SoundDetail {\n  ipa: string | null\n  phonetic: string | null // Native phonetic script (Japanese kana, Korean hangul)\n  romanization: string | null // Romanization (Chinese pinyin, Japanese romaji)\n  audio: string | null\n  ogg_url: string | null\n  mp3_url: string | null\n  tags: string[]\n}\n\nexport interface ExampleDetail {\n  text: string\n  translation: string | null\n  roman: string | null\n  bold_text_offsets: number[][] | null\n  bold_roman_offsets: number[][] | null\n  ref: string | null\n}\n\nexport interface GlossDetail {\n  text: string\n  order: number\n  example: ExampleDetail | null\n}\n\nexport interface SenseDetail {\n  ruby: string[][] | null\n  glosses: GlossDetail[]\n}\n\nexport interface EntryDetail {\n  entry_key: string // Entry key (composite: word:lang_code:native_lang_code:pos:source)\n  source: string | null\n  pos: string\n  forms: FormDetail[]\n  sounds: SoundDetail[]\n  senses: SenseDetail[]\n}\n\nexport interface EntryLookupResponse {\n  word: string\n  lang_code: string\n  entries: EntryDetail[]\n}\n\n// ============================================================================\n// Type Definitions - NLP Analysis API\n// ============================================================================\n\nexport interface AnalyzeRequest {\n  texts: string[]\n  language?: string\n}\n\nexport interface Token {\n  text: string\n  start: number\n  end: number\n  pos_tag: string\n  pos: string\n  pos_explanation: string\n  dep: string\n  head: number\n  head_text: string\n  lemma: string\n  is_merged: boolean // Indicates if this token was merged from multiple tokens (e.g., \"I'm\" from \"I\" + \"'m\")\n}\n\nexport interface Entity {\n  text: string\n  label: string\n  start: number\n  end: number\n}\n\nexport interface Romanization {\n  char: string\n  romanization: string\n  start: number\n  end: number\n}\n\nexport interface AnalyzeResponse {\n  tokens: Token[]\n  entities: Entity[]\n  language: string\n  romanization: Romanization[] | null\n}\n\n// ============================================================================\n// Type Definitions - Phrase Extraction API\n// ============================================================================\n\nexport interface PhraseExtractionRequest {\n  texts: string[]\n  language?: string\n  native_lng?: string\n}\n\nexport interface PhrasePosition {\n  word: string\n  start: number\n  end: number\n}\n\nexport interface Phrase {\n  phrase: string\n  meaning: string\n  positions: PhrasePosition[]\n  confidence: number\n  type?: string\n  explanation?: string\n}\n\nexport interface PhraseExtractionResponse {\n  phrases: Phrase[][]\n}\n\n// ============================================================================\n// Type Definitions - Language Detection API\n// ============================================================================\n\nexport interface LanguageDetectionRequest {\n  text: string\n}\n\nexport interface LanguageDetectionResponse {\n  language: string | null\n  confidence: number\n}\n\n// ============================================================================\n// Type Definitions - Authentication API\n// ============================================================================\n\nexport interface RegisterRequest {\n  email: string\n  password: string\n  name?: string\n  language?: string // User's browser language for i18n (e.g., 'zh-CN', 'en')\n}\n\nexport interface RegisterResponse {\n  message: string\n  email_sent: boolean\n}\n\nexport interface LoginRequest {\n  email: string\n  password: string\n}\n\nexport interface TokenResponse {\n  access_token: string\n  refresh_token: string\n  token_type: string\n  expires_in: number\n}\n\nexport interface VerifyEmailRequest {\n  token: string\n}\n\nexport interface ResendVerificationRequest {\n  email: string\n  language?: string // User's browser language for i18n (e.g., 'zh-CN', 'en')\n}\n\nexport interface VerificationMessageResponse {\n  message: string\n}\n\nexport interface UserResponse {\n  id: number\n  email: string\n  name: string | null\n  google_id: string | null\n  picture_url: string | null\n  is_active: boolean\n  is_verified: boolean\n  is_superuser: boolean\n  created_at: string\n  updated_at: string\n  settings: UserSettingsResponse | null\n}\n\n// ============================================================================\n// Type Definitions - Video View API\n// ============================================================================\n\nexport interface VideoViewCreateRequest {\n  platform?: string // Default: \"youtube\"\n  video_url: string\n  video_id: string\n  video_title: string\n  video_metadata?: string | null // JSON string\n}\n\nexport interface VideoInfo {\n  id: number\n  platform: string\n  video_url: string\n  video_id: string\n  video_title: string\n  video_metadata: Record<string, unknown> | null\n  created_at: string\n  updated_at: string\n}\n\nexport interface VideoViewResponse {\n  id: number\n  user_id: number\n  video_id: number\n  view_count: number\n  created_at: string\n  updated_at: string\n  video: VideoInfo\n}\n\nexport interface VideoViewListResponse {\n  items: VideoViewResponse[]\n  total: number\n  skip: number\n  limit: number\n}\n\n// ============================================================================\n// Type Definitions - User Settings API\n// ============================================================================\n\nexport interface UserSettingsResponse {\n  native_language: string\n  target_language: string\n  interface_language: string\n}\n\nexport interface UserSettingsUpdate {\n  native_language?: string\n  target_language?: string\n  interface_language?: string\n}\n\n// ============================================================================\n// Type Definitions - Video Collections API\n// ============================================================================\n\nexport interface VideoCollectionCreateRequest {\n  // Video view reference (from addVideoView API)\n  video_view_id: number\n  // Vocabulary information\n  word: string\n  sentence: string\n  translation: string\n  definitions: string\n  entry_key: string\n  phonetic?: string | null\n  pos?: string | null\n  lemma?: string | null\n  // Media resources\n  audio_base64: string\n  image_base64: string\n  audio_duration: number\n  // Video context\n  segment_begin: number\n  segment_end: number\n  source_language: string\n  target_language: string\n  phrases?: any[] | null\n}\n\nexport interface VideoCollectionResponse {\n  id: string\n  user_id: string\n  video_view_id: string\n  word: string\n  sentence: string\n  translation: string\n  audio_url: string\n  image_url: string\n  audio_duration: number\n  definitions: string\n  phonetic: string | null\n  pos: string | null\n  lemma: string | null\n  entry_key: string | null // Can be null if dictionary entry not found\n  segment_begin: number\n  segment_end: number\n  source_language: string\n  target_language: string\n  phrases: any[] | null\n  created_at: string\n  updated_at: string\n  video: {\n    id: string\n    platform: string\n    video_id: string\n    video_url: string\n    video_title: string\n  }\n  video_view: {\n    id: string\n    video_id: string\n    user_id: string\n    first_viewed_at: string\n    last_viewed_at: string\n  }\n  // Entry data from dictionary (populated via batch_lookup_entries_by_keys)\n  // Contains forms, sounds, senses with glosses and examples\n  // null if entry_key is null or entry not found in database\n  entry: EntryDetail | null\n}\n\nexport interface VideoCollectionListResponse {\n  total: number\n  items: VideoCollectionResponse[]\n  skip: number\n  limit: number\n}\n\n// ============================================================================\n// API Client - Singleton Class\n// ============================================================================\n\n/**\n * APIClient - Centralized HTTP client for backend API communication\n *\n * This singleton class provides type-safe methods for all backend APIs:\n * - Translation API: Multi-segment translation with language detection\n * - Dictionary API: Context-aware word lookup with 1-2 most likely definitions\n * - Entry Lookup API: Complete dictionary entry from database (forms, sounds, senses, etc.)\n * - NLP Analysis API: Comprehensive text analysis (tokenization, POS, NER, etc.)\n * - Phrase Extraction API: Extract idioms, phrasal verbs, collocations, and fixed expressions\n * - Language Detection API: Automatic language detection with confidence score\n * - Authentication API: User registration, login, logout, and token management\n * - Video View API: Track user-video viewing relationships\n * - Video Collections API: Create, retrieve, and manage vocabulary collections from videos\n *\n * Features:\n * - Singleton pattern for consistent state management\n * - Automatic retry logic with exponential backoff\n * - JWT token authentication with auto-refresh\n * - Integrated logging via Logger utility\n * - Full TypeScript type safety\n * - Environment-based configuration\n *\n * Usage:\n *   const client = APIClient.getInstance()\n *   await client.waitForInitialization() // Load tokens from storage\n *   const result = await client.translate({ segments: ['Hello'], source_lng: 'en' })\n *   const collections = await client.getVideoCollections()\n */\nexport class APIClient {\n  private static instance: APIClient\n  private baseUrl: string\n  private logger: Logger\n  private accessToken: string | null = null\n  private refreshToken: string | null = null\n  private tokenExpiresAt: number | null = null\n  private initializationPromise: Promise<void> | null = null\n  private cachedUser: UserResponse | null = null\n  private lastRefreshTime: number = 0\n  private isRefreshing: boolean = false\n  private refreshPromise: Promise<boolean> | null = null\n\n  /**\n   * Private constructor to enforce singleton pattern\n   */\n  private constructor() {\n    this.baseUrl = import.meta.env.VITE_BACKEND_URL || 'http://localhost:9999'\n    this.logger = new Logger('[APIClient]')\n    this.logger.info(`Initialized with baseUrl: ${this.baseUrl}`)\n    // Load tokens from storage on initialization\n    this.initializationPromise = this.loadTokensFromStorage()\n  }\n\n  /**\n   * Get the singleton instance of APIClient\n   */\n  public static getInstance(): APIClient {\n    if (!APIClient.instance) {\n      APIClient.instance = new APIClient()\n    }\n    return APIClient.instance\n  }\n\n  /**\n   * Wait for the client to finish initialization (loading tokens from storage)\n   * This should be called before checking authentication status\n   */\n  public async waitForInitialization(): Promise<void> {\n    if (this.initializationPromise) {\n      await this.initializationPromise\n      this.initializationPromise = null\n    }\n  }\n\n  // ==========================================================================\n  // Public API Methods\n  // ==========================================================================\n\n  /**\n   * Translate multiple text segments\n   *\n   * @param request - Translation request with segments and language options\n   * @returns Translated segments in the same order\n   * @throws Error if translation fails after retries\n   *\n   * @example\n   * const result = await client.translate({\n   *   segments: ['Hello', 'World'],\n   *   source_lng: 'en',\n   *   target_lng: 'zh-CN'\n   * })\n   * console.log(result.segments) // ['你好', '世界']\n   */\n  public async translate(request: TranslateRequest): Promise<TranslateResponse> {\n    this.logger.debug('translate() called with:', request)\n\n    return await this.request<TranslateResponse>('/api/translate', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(request),\n    })\n  }\n\n  /**\n   * Look up a word definition with context awareness\n   *\n   * @param request - Lookup request with word, context, and native language\n   * @returns Array of 1-2 definitions (most likely meanings)\n   * @throws Error if lookup fails after retries\n   *\n   * @example\n   * const definitions = await client.lookupWord({\n   *   word: 'bank',\n   *   context: 'I went to the bank to deposit money',\n   *   native_lng: 'zh-CN'\n   * })\n   * console.log(definitions)\n   * // [{ meaning: '银行' }, { meaning: '河岸' }]\n   */\n  public async lookupWord(request: LookupRequest): Promise<Definition[]> {\n    this.logger.debug('lookupWord() called with:', request)\n\n    return await this.request<Definition[]>('/api/dictionary/lookup', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(request),\n    })\n  }\n\n  /**\n   * Look up complete entry information from database\n   *\n   * @param word - Word or phrase to look up\n   * @param lang_code - Language code (e.g., \"en\", \"zh-CN\", \"ja\")\n   * @param native_lang_code - Language of glosses and examples (default: \"zh-CN\")\n   * @param source - Optional dictionary source filter (e.g., \"wiktionary\")\n   * @param pos - Optional part-of-speech filter (e.g., \"noun\", \"verb\")\n   * @returns Complete entry information or null if not found\n   * @throws Error if lookup fails after retries\n   *\n   * @example\n   * const entry = await client.lookupEntry('三昧', 'ja', 'zh-CN')\n   * console.log(entry)\n   * // {\n   * //   word: '三昧',\n   * //   lang_code: 'ja',\n   * //   entries: [\n   * //     {\n   * //       source: 'wiktionary',\n   * //       pos: 'unknown',\n   * //       forms: [{ form: '三昧', tags: ['canonical'] }, ...],\n   * //       sounds: [{ ipa: '[sã̠mːa̠i]', ... }],\n   * //       senses: [{ glosses: [...], examples: [...] }]\n   * //     }\n   * //   ]\n   * // }\n   */\n  public async lookupEntry(\n    word: string,\n    lang_code: string,\n    native_lang_code: string = 'zh-CN',\n    source?: string,\n    pos?: string,\n  ): Promise<EntryLookupResponse | null> {\n    this.logger.debug('lookupEntry() called with:', {\n      word,\n      lang_code,\n      native_lang_code,\n      source,\n      pos,\n    })\n\n    // Build query parameters\n    const params = new URLSearchParams({ word, lang_code, native_lang_code })\n    if (source) params.append('source', source)\n    if (pos) params.append('pos', pos)\n\n    try {\n      return await this.request<EntryLookupResponse>(\n        `/api/dictionary/entry?${params.toString()}`,\n        {\n          method: 'GET',\n        },\n        1, // 不重试，404 是正常的未找到情况\n      )\n    } catch (error) {\n      // If 404, return null (entry not found)\n      if (error instanceof Error && error.message.includes('404')) {\n        this.logger.info(`Entry not found: ${word} (${lang_code})`)\n        return null\n      }\n      // Re-throw other errors\n      throw error\n    }\n  }\n\n  /**\n   * Perform comprehensive NLP analysis on texts (batch processing)\n   *\n   * @param request - Analysis request with texts array and language\n   * @returns Array of NLP analysis results, one for each text\n   * @throws Error if analysis fails after retries\n   *\n   * @example\n   * const results = await client.analyzeText({\n   *   texts: ['Apple is looking at buying U.K. startup', 'Hello world'],\n   *   language: 'en'\n   * })\n   * console.log(results[0].entities)\n   * // [{ text: 'Apple', label: 'ORG', ... }, { text: 'U.K.', label: 'GPE', ... }]\n   */\n  public async analyzeText(request: AnalyzeRequest): Promise<AnalyzeResponse[]> {\n    this.logger.debug('analyzeText() called with:', request)\n\n    return await this.request<AnalyzeResponse[]>('/api/nlp/analyze', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(request),\n    })\n  }\n\n  /**\n   * Extract phrases (idioms, phrasal verbs, collocations, etc.) from texts (batch processing)\n   *\n   * @param request - Phrase extraction request with texts array, language, and native language\n   * @returns Array of phrase lists, each corresponding to an input text\n   * @throws Error if extraction fails after retries\n   *\n   * @example\n   * const result = await client.extractPhrases({\n   *   texts: ['I need to look it up', 'Break the ice'],\n   *   language: 'en',\n   *   native_lng: 'zh-CN'\n   * })\n   * console.log(result.phrases)\n   * // [\n   * //   [{ phrase: 'look up', meaning: '查找', ... }],\n   * //   [{ phrase: 'break the ice', meaning: '打破僵局', ... }]\n   * // ]\n   */\n  public async extractPhrases(request: PhraseExtractionRequest): Promise<PhraseExtractionResponse> {\n    this.logger.debug('extractPhrases() called with:', request)\n\n    return await this.request<PhraseExtractionResponse>('/api/nlp/extract-phrases', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(request),\n    })\n  }\n\n  /**\n   * Detect the language of given text\n   *\n   * @param request - Language detection request with text\n   * @returns Detected language code and confidence score\n   * @throws Error if detection fails after retries\n   *\n   * @example\n   * const result = await client.detectLanguage({\n   *   text: 'Hello world'\n   * })\n   * console.log(result)\n   * // { language: 'en', confidence: 0.93 }\n   *\n   * @example\n   * const result = await client.detectLanguage({\n   *   text: '你好世界'\n   * })\n   * console.log(result)\n   * // { language: 'zh-CN', confidence: 0.95 }\n   */\n  public async detectLanguage(\n    request: LanguageDetectionRequest,\n  ): Promise<LanguageDetectionResponse> {\n    this.logger.debug('detectLanguage() called with:', request)\n\n    return await this.request<LanguageDetectionResponse>('/api/nlp/detect-language', {\n      method: 'POST',\n      headers: { 'Content-Type': 'application/json' },\n      body: JSON.stringify(request),\n    })\n  }\n\n  /**\n   * Register a new user account\n   *\n   * Creates user with is_verified=False and sends verification email.\n   * User must verify email before they can login.\n   *\n   * @param request - Registration request with email, password, optional name, and optional language\n   * @returns Success message and email_sent status\n   * @throws Error if registration fails (e.g., email already registered)\n   *\n   * @example\n   * const result = await client.register({\n   *   email: 'user@example.com',\n   *   password: 'password123',\n   *   name: 'John Doe',\n   *   language: 'zh-CN' // For i18n email content\n   * })\n   * console.log(result.message) // \"Registration successful. Please check your email...\"\n   * console.log(result.email_sent) // true\n   */\n  public async register(request: RegisterRequest): Promise<RegisterResponse> {\n    this.logger.debug('register() called with:', { email: request.email })\n\n    return await this.request<RegisterResponse>(\n      '/api/auth/register',\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(request),\n      },\n      1, // No retry for registration\n    )\n  }\n\n  /**\n   * Verify email with token and automatically login\n   *\n   * Validates the verification token, marks user as verified,\n   * and returns JWT tokens for automatic login.\n   *\n   * @param token - Verification token from email\n   * @returns JWT tokens (access_token and refresh_token) for automatic login\n   * @throws Error if token is invalid or expired\n   *\n   * @example\n   * const tokens = await client.verifyEmail('abc123...')\n   * // User is now verified and logged in\n   * // Tokens are automatically stored\n   */\n  public async verifyEmail(token: string): Promise<TokenResponse> {\n    this.logger.debug('verifyEmail() called')\n\n    const tokens = await this.request<TokenResponse>(\n      '/api/auth/verify-email',\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ token, client_type: 'extension' }),\n      },\n      1, // No retry for verification\n    )\n\n    // Store tokens automatically (user is now logged in)\n    await this.setTokens(tokens)\n\n    return tokens\n  }\n\n  /**\n   * Resend verification email\n   *\n   * Generates a new verification token and sends it to the user's email.\n   *\n   * @param email - Email address to resend verification to\n   * @param language - User's browser language for i18n (e.g., 'zh-CN', 'en')\n   * @returns Success message\n   * @throws Error if user already verified or email sending fails\n   *\n   * @example\n   * const result = await client.resendVerification('user@example.com', 'zh-CN')\n   * console.log(result.message) // \"Verification code sent. Please check your email.\"\n   */\n  public async resendVerification(\n    email: string,\n    language?: string,\n  ): Promise<VerificationMessageResponse> {\n    this.logger.debug('resendVerification() called with:', { email })\n\n    return await this.request<VerificationMessageResponse>(\n      '/api/auth/resend-verification',\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ email, language }),\n      },\n      1, // No retry for resend\n    )\n  }\n\n  /**\n   * Login with email and password\n   *\n   * @param request - Login request with email and password\n   * @returns JWT tokens (access_token and refresh_token)\n   * @throws Error if login fails\n   *\n   * @example\n   * const tokens = await client.login({\n   *   email: 'user@example.com',\n   *   password: 'password123'\n   * })\n   * // Tokens are automatically stored\n   */\n  public async login(request: LoginRequest): Promise<TokenResponse> {\n    this.logger.debug('login() called with:', { email: request.email })\n\n    const tokens = await this.request<TokenResponse>(\n      '/api/auth/login',\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ ...request, client_type: 'extension' }),\n      },\n      1, // No retry for login\n    )\n\n    // Store tokens automatically\n    await this.setTokens(tokens)\n\n    return tokens\n  }\n\n  /**\n   * Login with Google OAuth token\n   *\n   * Exchanges a Google OAuth access token for JWT tokens.\n   * The backend verifies the Google token, creates/retrieves the user,\n   * and returns JWT tokens.\n   *\n   * @param googleToken - Google OAuth access token from chrome.identity.launchWebAuthFlow()\n   * @returns JWT tokens\n   * @throws Error if login fails\n   *\n   * @example\n   * const tokens = await client.loginWithGoogle(googleAccessToken)\n   * // Tokens are automatically stored\n   */\n  public async loginWithGoogle(googleToken: string): Promise<TokenResponse> {\n    this.logger.debug('loginWithGoogle() called')\n\n    const tokens = await this.request<TokenResponse>(\n      '/api/auth/google',\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ google_token: googleToken, client_type: 'extension' }),\n      },\n      1, // No retry for login\n    )\n\n    // Store tokens automatically\n    await this.setTokens(tokens)\n\n    return tokens\n  }\n\n  /**\n   * Logout and revoke refresh token\n   *\n   * @throws Error if logout fails\n   *\n   * @example\n   * await client.logout()\n   * // Tokens are automatically cleared\n   */\n  public async logout(): Promise<void> {\n    this.logger.debug('logout() called')\n\n    if (!this.refreshToken) {\n      this.logger.warn('No refresh token found, cannot logout')\n      return\n    }\n\n    try {\n      await this.request<{ message: string }>(\n        '/api/auth/logout',\n        {\n          method: 'POST',\n          headers: { 'Content-Type': 'application/json' },\n          body: JSON.stringify({ refresh_token: this.refreshToken }),\n        },\n        1, // No retry for logout\n        true, // Don't try to refresh if logout returns 401 (we're logging out anyway)\n      )\n    } finally {\n      // Clear tokens regardless of API response\n      await this.clearTokens()\n    }\n  }\n\n  /**\n   * Refresh access token using refresh token\n   *\n   * @returns New JWT tokens\n   * @throws Error if refresh fails\n   *\n   * @example\n   * const tokens = await client.refreshAccessToken()\n   * // New tokens are automatically stored\n   */\n  public async refreshAccessToken(): Promise<TokenResponse> {\n    this.logger.debug('refreshAccessToken() called')\n\n    if (!this.refreshToken) {\n      throw new Error('No refresh token available')\n    }\n\n    const tokens = await this.request<TokenResponse>(\n      '/api/auth/refresh',\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify({ refresh_token: this.refreshToken }),\n      },\n      1, // No retry for token refresh\n      true, // IMPORTANT: Don't try to refresh again if this returns 401 (prevents infinite loop)\n    )\n\n    // Store new tokens automatically\n    await this.setTokens(tokens)\n\n    return tokens\n  }\n\n  /**\n   * Get current user information\n   *\n   * @returns User information\n   * @throws Error if request fails or user is not authenticated\n   *\n   * @example\n   * const user = await client.getCurrentUser()\n   * console.log(user.email)\n   */\n  public async getCurrentUser(): Promise<UserResponse> {\n    this.logger.debug('getCurrentUser() called')\n\n    const user = await this.request<UserResponse>('/api/auth/me', {\n      method: 'GET',\n    })\n\n    // Cache user data on success\n    await this.cacheUser(user)\n\n    return user\n  }\n\n  /**\n   * Get cached user information without making API request\n   *\n   * @returns Cached user information or null if not available\n   */\n  public getCachedUser(): UserResponse | null {\n    return this.cachedUser\n  }\n\n  /**\n   * Check if user is authenticated (has valid access token)\n   * If token is expired but refresh token is available, automatically refresh\n   *\n   * @returns true if user is authenticated (or successfully refreshed), false otherwise\n   */\n  public async isAuthenticated(): Promise<boolean> {\n    // 1. If no access token, return false immediately\n    if (!this.accessToken) {\n      return false\n    }\n\n    // 2. If token is not expired, return true\n    if (!this.isTokenExpired()) {\n      return true\n    }\n\n    // 3. Token is expired, try to refresh\n    if (!this.refreshToken) {\n      this.logger.warn('Access token expired and no refresh token available')\n      return false\n    }\n\n    // 4. Check if we recently refreshed (防抖优化：5 分钟内不重复刷新)\n    const now = Date.now()\n    if (now - this.lastRefreshTime < 5 * 60 * 1000) {\n      this.logger.debug('Token refreshed recently, skipping refresh')\n      return true\n    }\n\n    // 5. If already refreshing, wait for the existing refresh to complete\n    if (this.isRefreshing && this.refreshPromise) {\n      this.logger.debug('Token refresh already in progress, waiting...')\n      return await this.refreshPromise\n    }\n\n    // 6. Start refreshing\n    this.isRefreshing = true\n    this.refreshPromise = (async () => {\n      try {\n        this.logger.info('Access token expired, attempting to refresh...')\n        await this.refreshAccessToken()\n        this.lastRefreshTime = Date.now()\n        this.logger.info('Token refresh successful')\n        return true\n      } catch (error) {\n        this.logger.error('Token refresh failed:', error)\n        await this.clearTokens()\n        return false\n      } finally {\n        this.isRefreshing = false\n        this.refreshPromise = null\n      }\n    })()\n\n    return await this.refreshPromise\n  }\n\n  /**\n   * Get current access token\n   */\n  public getAccessToken(): string | null {\n    return this.accessToken\n  }\n\n  /**\n   * Get current user's settings from the backend\n   *\n   * @returns User settings including language preferences\n   * @throws Error if request fails or user is not authenticated\n   *\n   * @example\n   * const settings = await client.getUserSettings()\n   * console.log(settings.native_language) // 'zh-CN'\n   */\n  public async getUserSettings(): Promise<UserSettingsResponse> {\n    this.logger.debug('getUserSettings() called')\n\n    return await this.request<UserSettingsResponse>('/api/user/settings', {\n      method: 'GET',\n    })\n  }\n\n  /**\n   * Update current user's settings on the backend\n   *\n   * @param settings - Partial settings to update (only non-null fields are updated)\n   * @returns Updated user settings\n   * @throws Error if update fails or user is not authenticated\n   *\n   * @example\n   * const updated = await client.updateUserSettings({\n   *   native_language: 'en',\n   *   target_language: 'ja'\n   * })\n   */\n  public async updateUserSettings(settings: UserSettingsUpdate): Promise<UserSettingsResponse> {\n    this.logger.debug('updateUserSettings() called with:', settings)\n\n    return await this.request<UserSettingsResponse>(\n      '/api/user/settings',\n      {\n        method: 'PUT',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(settings),\n      },\n      1, // No retry for settings update\n    )\n  }\n\n  /**\n   * Add or update a video view record\n   *\n   * This endpoint handles the complete flow:\n   * 1. Creates/updates video record (upsert by video_id)\n   * 2. Creates/updates video view record (upsert by user_id + video_id)\n   *\n   * @param request - Video view request with platform, URL, ID, title, and optional metadata\n   * @returns VideoViewResponse with video_view_id and video information\n   * @throws Error if creation fails (500 for server error)\n   *\n   * @example\n   * const videoView = await client.addVideoView({\n   *   platform: 'youtube',\n   *   video_url: 'https://www.youtube.com/watch?v=abc123',\n   *   video_id: 'abc123',\n   *   video_title: 'Learn English'\n   * })\n   * console.log(videoView.id, videoView.view_count)\n   */\n  public async addVideoView(request: VideoViewCreateRequest): Promise<VideoViewResponse> {\n    this.logger.debug('addVideoView() called with:', {\n      video_id: request.video_id,\n      platform: request.platform,\n    })\n\n    return await this.request<VideoViewResponse>(\n      '/api/video-views',\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(request),\n      },\n      1, // No retry for creation\n    )\n  }\n\n  /**\n   * Get a specific video view by ID\n   *\n   * @param videoViewId - Video view ID\n   * @returns VideoViewResponse with video_view and video information\n   * @throws Error if not found (404) or access denied (403)\n   *\n   * @example\n   * const videoView = await client.getVideoView(123)\n   * console.log(videoView.video.video_title, videoView.view_count)\n   */\n  public async getVideoView(videoViewId: number): Promise<VideoViewResponse> {\n    this.logger.debug('getVideoView() called with:', { videoViewId })\n\n    return await this.request<VideoViewResponse>(`/api/video-views/${videoViewId}`, {\n      method: 'GET',\n    })\n  }\n\n  /**\n   * List video views for current user with pagination\n   *\n   * @param options - Query options (skip, limit)\n   * @returns Paginated list of video views ordered by most recently viewed first\n   * @throws Error if retrieval fails\n   *\n   * @example\n   * // Get recent video views\n   * const result = await client.listVideoViews()\n   * console.log(result.total, result.items)\n   *\n   * @example\n   * // Get paginated video views\n   * const result = await client.listVideoViews({\n   *   skip: 0,\n   *   limit: 20\n   * })\n   */\n  public async listVideoViews(options?: {\n    skip?: number\n    limit?: number\n  }): Promise<VideoViewListResponse> {\n    this.logger.debug('listVideoViews() called with:', options)\n\n    // Build query parameters\n    const params = new URLSearchParams()\n    if (options?.skip !== undefined) params.append('skip', options.skip.toString())\n    if (options?.limit !== undefined) params.append('limit', options.limit.toString())\n\n    const endpoint = params.toString()\n      ? `/api/video-views?${params.toString()}`\n      : '/api/video-views'\n\n    return await this.request<VideoViewListResponse>(endpoint, {\n      method: 'GET',\n    })\n  }\n\n  /**\n   * Create a new video collection item\n   *\n   * @param request - Collection creation request with video_view_id, vocabulary, media, and video context\n   * @returns Created collection with video and video_view information\n   * @throws Error if creation fails (400 for validation, 409 for duplicate, 500 for server error)\n   *\n   * @example\n   * const collection = await client.createVideoCollection({\n   *   video_view_id: 123, // From addVideoView API\n   *   word: 'hello',\n   *   sentence: 'Hello world',\n   *   translation: '你好世界',\n   *   definitions: 'a greeting',\n   *   entry_key: 'hello:en:zh-CN:noun:oxford',\n   *   audio_base64: 'data:audio/mp3;base64,...',\n   *   image_base64: 'data:image/png;base64,...',\n   *   audio_duration: 1500,\n   *   segment_begin: 1000,\n   *   segment_end: 3000,\n   *   source_language: 'en',\n   *   target_language: 'zh-CN',\n   * })\n   */\n  public async createVideoCollection(\n    request: VideoCollectionCreateRequest,\n  ): Promise<VideoCollectionResponse> {\n    this.logger.debug('createVideoCollection() called with:', {\n      word: request.word,\n      video_view_id: request.video_view_id,\n    })\n\n    return await this.request<VideoCollectionResponse>(\n      '/api/video-collections',\n      {\n        method: 'POST',\n        headers: { 'Content-Type': 'application/json' },\n        body: JSON.stringify(request),\n      },\n      1, // No retry for creation\n    )\n  }\n\n  /**\n   * Get video collections for current user with optional filters\n   *\n   * @param options - Query options (skip, limit, video_view_id, source_language)\n   * @returns Paginated list of collections\n   * @throws Error if retrieval fails\n   *\n   * @example\n   * // Get all collections\n   * const result = await client.getVideoCollections()\n   * console.log(result.total, result.items)\n   *\n   * @example\n   * // Get collections for a specific video view\n   * const result = await client.getVideoCollections({\n   *   video_view_id: 'abc-123',\n   *   source_language: 'en',\n   *   skip: 0,\n   *   limit: 50\n   * })\n   */\n  public async getVideoCollections(options?: {\n    skip?: number\n    limit?: number\n    video_view_id?: number\n    source_language?: string\n  }): Promise<VideoCollectionListResponse> {\n    this.logger.debug('getVideoCollections() called with:', options)\n\n    // Build query parameters\n    const params = new URLSearchParams()\n    if (options?.skip !== undefined) params.append('skip', options.skip.toString())\n    if (options?.limit !== undefined) params.append('limit', options.limit.toString())\n    if (options?.video_view_id !== undefined)\n      params.append('video_view_id', options.video_view_id.toString())\n    if (options?.source_language) params.append('source_language', options.source_language)\n\n    const endpoint = params.toString()\n      ? `/api/video-collections?${params.toString()}`\n      : '/api/video-collections'\n\n    return await this.request<VideoCollectionListResponse>(endpoint, {\n      method: 'GET',\n    })\n  }\n\n  /**\n   * Get a specific video collection by ID\n   *\n   * @param collectionId - Collection UUID\n   * @returns Collection data with video and video_view information\n   * @throws Error if not found (404) or access denied (403)\n   *\n   * @example\n   * const collection = await client.getVideoCollection('abc-123-def-456')\n   * console.log(collection.word, collection.video.video_title)\n   */\n  public async getVideoCollection(collectionId: string): Promise<VideoCollectionResponse> {\n    this.logger.debug('getVideoCollection() called with:', { collectionId })\n\n    return await this.request<VideoCollectionResponse>(`/api/video-collections/${collectionId}`, {\n      method: 'GET',\n    })\n  }\n\n  /**\n   * Delete a video collection\n   *\n   * @param collectionId - Collection UUID to delete\n   * @returns void (204 No Content on success)\n   * @throws Error if not found (404) or access denied (403)\n   *\n   * @example\n   * await client.deleteVideoCollection('abc-123-def-456')\n   * console.log('Collection deleted successfully')\n   */\n  public async deleteVideoCollection(collectionId: string): Promise<void> {\n    this.logger.debug('deleteVideoCollection() called with:', { collectionId })\n\n    await this.request<void>(\n      `/api/video-collections/${collectionId}`,\n      {\n        method: 'DELETE',\n      },\n      1, // No retry for deletion\n    )\n  }\n\n  // ==========================================================================\n  // Private Helper Methods\n  // ==========================================================================\n\n  /**\n   * Generic HTTP request handler with retry logic and automatic 401 token refresh\n   *\n   * @param endpoint - API endpoint path (e.g., '/api/translate')\n   * @param options - Fetch API options\n   * @param maxRetries - Maximum number of retry attempts (default: 3)\n   * @param hasTriedRefresh - Internal flag to prevent infinite refresh loops\n   * @returns Parsed JSON response\n   * @throws Error if all retry attempts fail\n   */\n  private async request<T>(\n    endpoint: string,\n    options: RequestInit,\n    maxRetries: number = 3,\n    hasTriedRefresh: boolean = false,\n  ): Promise<T> {\n    const url = `${this.baseUrl}${endpoint}`\n\n    // Add Authorization header if access token is available\n    if (this.accessToken) {\n      options.headers = {\n        ...options.headers,\n        Authorization: `Bearer ${this.accessToken}`,\n      }\n    }\n\n    for (let attempt = 1; attempt <= maxRetries; attempt++) {\n      try {\n        this.logger.debug(`Request attempt ${attempt}/${maxRetries} to ${url}`)\n\n        const response = await fetch(url, options)\n\n        // Handle 401 Unauthorized - try to refresh token and retry\n        if (response.status === 401 && !hasTriedRefresh && this.refreshToken) {\n          this.logger.info('Received 401, attempting to refresh token...')\n          try {\n            await this.refreshAccessToken()\n            this.logger.info('Token refreshed successfully, retrying request...')\n            // Update Authorization header with new token and retry\n            options.headers = {\n              ...options.headers,\n              Authorization: `Bearer ${this.accessToken}`,\n            }\n            // Retry with hasTriedRefresh=true to prevent infinite loops\n            return await this.request<T>(endpoint, options, maxRetries, true)\n          } catch (refreshError) {\n            this.logger.error('Token refresh failed:', refreshError)\n            // Clear tokens and throw the original 401 error\n            await this.clearTokens()\n            const errorText = await response.text().catch(() => 'Unauthorized')\n            throw new Error(`HTTP 401 Unauthorized: ${errorText}`)\n          }\n        }\n\n        if (!response.ok) {\n          const errorText = await response.text().catch(() => 'Unknown error')\n          throw new Error(`HTTP ${response.status} ${response.statusText}: ${errorText}`)\n        }\n\n        // Handle 204 No Content responses (e.g., DELETE requests)\n        if (response.status === 204) {\n          this.logger.debug(`Request successful on attempt ${attempt} (204 No Content)`)\n          return undefined as T\n        }\n\n        const data = (await response.json()) as T\n        this.logger.debug(`Request successful on attempt ${attempt}`)\n        return data\n      } catch (error) {\n        const errorMessage = error instanceof Error ? error.message : String(error)\n        this.logger.warn(`Request failed (attempt ${attempt}/${maxRetries}):`, errorMessage)\n\n        // If this was the last attempt, throw the error\n        if (attempt === maxRetries) {\n          this.logger.error(`All ${maxRetries} attempts failed for ${url}`)\n          throw new Error(`API request failed after ${maxRetries} attempts: ${errorMessage}`)\n        }\n\n        // Wait before retrying (exponential backoff: 1s, 2s, 4s, ...)\n        const delayMs = Math.pow(2, attempt - 1) * 1000\n        this.logger.debug(`Waiting ${delayMs}ms before retry...`)\n        await new Promise((resolve) => setTimeout(resolve, delayMs))\n      }\n    }\n\n    // This should never be reached, but TypeScript requires it\n    throw new Error('Unexpected error in request handler')\n  }\n\n  /**\n   * Load tokens and cached user from chrome.storage.local\n   */\n  private async loadTokensFromStorage(): Promise<void> {\n    try {\n      const result = await chrome.storage.local.get([\n        'access_token',\n        'refresh_token',\n        'token_expires_at',\n        'cached_user',\n      ])\n\n      this.accessToken = result.access_token || null\n      this.refreshToken = result.refresh_token || null\n      this.tokenExpiresAt = result.token_expires_at || null\n      this.cachedUser = result.cached_user || null\n\n      if (this.accessToken) {\n        this.logger.info('Tokens loaded from storage')\n      }\n      if (this.cachedUser) {\n        this.logger.info('Cached user loaded from storage')\n      }\n    } catch (error) {\n      this.logger.error('Failed to load tokens from storage:', error)\n    }\n  }\n\n  /**\n   * Store tokens to chrome.storage.local and update instance variables\n   */\n  private async setTokens(tokens: TokenResponse): Promise<void> {\n    this.accessToken = tokens.access_token\n    this.refreshToken = tokens.refresh_token\n    // Calculate token expiration time (current time + expires_in seconds)\n    this.tokenExpiresAt = Date.now() + tokens.expires_in * 1000\n\n    try {\n      await chrome.storage.local.set({\n        access_token: this.accessToken,\n        refresh_token: this.refreshToken,\n        token_expires_at: this.tokenExpiresAt,\n      })\n      this.logger.info('Tokens stored successfully')\n    } catch (error) {\n      this.logger.error('Failed to store tokens:', error)\n      throw error\n    }\n  }\n\n  /**\n   * Clear tokens and cached user from both instance and chrome.storage.local\n   */\n  private async clearTokens(): Promise<void> {\n    this.accessToken = null\n    this.refreshToken = null\n    this.tokenExpiresAt = null\n    this.cachedUser = null\n\n    try {\n      await chrome.storage.local.remove([\n        'access_token',\n        'refresh_token',\n        'token_expires_at',\n        'cached_user',\n      ])\n      this.logger.info('Tokens and cached user cleared')\n    } catch (error) {\n      this.logger.error('Failed to clear tokens:', error)\n    }\n  }\n\n  /**\n   * Cache user information to both instance and chrome.storage.local\n   */\n  private async cacheUser(user: UserResponse): Promise<void> {\n    this.cachedUser = user\n\n    try {\n      await chrome.storage.local.set({\n        cached_user: user,\n      })\n      this.logger.info('User cached successfully')\n    } catch (error) {\n      this.logger.error('Failed to cache user:', error)\n    }\n  }\n\n  /**\n   * Check if access token is expired\n   */\n  private isTokenExpired(): boolean {\n    if (!this.tokenExpiresAt) {\n      return true\n    }\n    // Add 60 second buffer to refresh token before it actually expires\n    return Date.now() >= this.tokenExpiresAt - 60000\n  }\n}\n","/**\n * AuthMessageHandler - Handles all authentication-related messages in Background Service\n *\n * Centralizes auth logic: CHECK_AUTH, LOGIN, LOGOUT, REGISTER, GET_USER\n * Also handles broadcasting auth state changes to Content Scripts.\n */\n\nimport { APIClient } from '../tools/client'\nimport { Logger } from '../tools/logger'\nimport { MessageSource, MessageType } from '../types/messages'\nimport { SettingsHandler } from './settingsHandler'\nimport { setUser as setSentryUser, clearUser as clearSentryUser } from '../tools/sentryClient'\n\nexport class AuthMessageHandler {\n  constructor(\n    private apiClient: APIClient,\n    private logger: Logger,\n    private settingsHandler: SettingsHandler,\n  ) {}\n\n  /**\n   * Initialize Sentry user on extension startup if already logged in\n   * Should be called after APIClient initialization\n   */\n  async initSentryUser(): Promise<void> {\n    try {\n      await this.apiClient.waitForInitialization()\n      const isAuth = await this.apiClient.isAuthenticated()\n      if (isAuth) {\n        const user = this.apiClient.getCachedUser() || (await this.apiClient.getCurrentUser())\n        if (user) {\n          setSentryUser(String(user.id), user.email)\n          this.logger.debug('Sentry user initialized on startup')\n        }\n      }\n    } catch (error) {\n      this.logger.error('Failed to initialize Sentry user:', error)\n    }\n  }\n\n  /**\n   * Check if the message type is auth-related and can be handled by this handler\n   */\n  canHandle(messageType: MessageType): boolean {\n    return [\n      MessageType.CHECK_AUTH,\n      MessageType.AUTH_LOGIN,\n      MessageType.AUTH_LOGOUT,\n      MessageType.AUTH_REGISTER,\n      MessageType.AUTH_GET_USER,\n      MessageType.AUTH_GOOGLE_LOGIN,\n      MessageType.AUTH_VERIFY_EMAIL,\n      MessageType.AUTH_RESEND_VERIFICATION,\n    ].includes(messageType)\n  }\n\n  /**\n   * Handle CHECK_AUTH from Content Script\n   * Returns only authenticated status (no user info)\n   */\n  async handleContentScriptCheckAuth(sendResponse: (response: unknown) => void): Promise<void> {\n    try {\n      await this.apiClient.waitForInitialization()\n      const authenticated = await this.apiClient.isAuthenticated()\n      sendResponse({\n        source: MessageSource.BACKGROUND,\n        type: MessageType.CHECK_AUTH_RESPONSE,\n        data: { authenticated },\n        timestamp: Date.now(),\n      })\n    } catch (error) {\n      this.logger.error('Failed to check authentication:', error)\n      sendResponse({\n        source: MessageSource.BACKGROUND,\n        type: MessageType.CHECK_AUTH_RESPONSE,\n        data: { authenticated: false },\n        timestamp: Date.now(),\n      })\n    }\n  }\n\n  /**\n   * Handle CHECK_AUTH from Popup\n   * Returns authenticated status and user info if authenticated\n   */\n  async handlePopupCheckAuth(sendResponse: (response: unknown) => void): Promise<void> {\n    try {\n      await this.apiClient.waitForInitialization()\n      const authenticated = await this.apiClient.isAuthenticated()\n      let user = null\n      if (authenticated) {\n        user = this.apiClient.getCachedUser() || (await this.apiClient.getCurrentUser())\n      }\n      sendResponse({\n        source: MessageSource.BACKGROUND,\n        type: MessageType.CHECK_AUTH_RESPONSE,\n        data: { authenticated, user },\n        timestamp: Date.now(),\n      })\n    } catch (error) {\n      this.logger.error('Failed to check authentication:', error)\n      sendResponse({\n        source: MessageSource.BACKGROUND,\n        type: MessageType.CHECK_AUTH_RESPONSE,\n        data: { authenticated: false },\n        timestamp: Date.now(),\n      })\n    }\n  }\n\n  /**\n   * Handle AUTH_LOGIN from Popup\n   */\n  async handleLogin(\n    data: { email: string; password: string },\n    sendResponse: (response: unknown) => void,\n  ): Promise<void> {\n    try {\n      await this.apiClient.login(data)\n      const user = await this.apiClient.getCurrentUser()\n      sendResponse({ success: true, user })\n      this.broadcastAuthStateChange(true)\n\n      // Set Sentry user for error tracking\n      setSentryUser(String(user.id), user.email)\n\n      // Save settings from user response (no extra API call needed)\n      if (user.settings) {\n        await this.settingsHandler.saveFromBackend(user.settings)\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Login failed'\n      this.logger.error('Login failed:', error)\n      sendResponse({ success: false, error: errorMessage })\n    }\n  }\n\n  /**\n   * Handle AUTH_LOGOUT from Popup\n   */\n  async handleLogout(sendResponse: (response: unknown) => void): Promise<void> {\n    try {\n      await this.apiClient.logout()\n\n      // Clear user settings from storage\n      await chrome.storage.sync.remove(['nativeLanguage', 'targetLanguage', 'interfaceLanguage'])\n\n      // Clear Sentry user for error tracking\n      clearSentryUser()\n\n      sendResponse({ success: true })\n      this.broadcastAuthStateChange(false)\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Logout failed'\n      this.logger.error('Logout failed:', error)\n      sendResponse({ success: false, error: errorMessage })\n    }\n  }\n\n  /**\n   * Handle AUTH_REGISTER from Popup\n   *\n   * Registration now requires email verification. The response contains\n   * a message and email_sent status instead of auto-login tokens.\n   */\n  async handleRegister(\n    data: { email: string; password: string; name?: string; language?: string },\n    sendResponse: (response: unknown) => void,\n  ): Promise<void> {\n    try {\n      const result = await this.apiClient.register(data)\n      sendResponse({ success: true, data: result })\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Registration failed'\n      this.logger.error('Registration failed:', error)\n      sendResponse({ success: false, error: errorMessage })\n    }\n  }\n\n  /**\n   * Handle AUTH_VERIFY_EMAIL from Popup\n   *\n   * Verifies user email with the provided code. On success, user is automatically\n   * logged in and JWT tokens are stored.\n   */\n  async handleVerifyEmail(\n    data: { code: string },\n    sendResponse: (response: unknown) => void,\n  ): Promise<void> {\n    try {\n      await this.apiClient.verifyEmail(data.code)\n      const user = await this.apiClient.getCurrentUser()\n      sendResponse({ success: true, user })\n      this.broadcastAuthStateChange(true)\n\n      // Set Sentry user for error tracking\n      setSentryUser(String(user.id), user.email)\n\n      // Save settings from user response (no extra API call needed)\n      if (user.settings) {\n        await this.settingsHandler.saveFromBackend(user.settings)\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Verification failed'\n      this.logger.error('Email verification failed:', error)\n      sendResponse({ success: false, error: errorMessage })\n    }\n  }\n\n  /**\n   * Handle AUTH_RESEND_VERIFICATION from Popup\n   *\n   * Resends verification email to the specified address.\n   */\n  async handleResendVerification(\n    data: { email: string; language?: string },\n    sendResponse: (response: unknown) => void,\n  ): Promise<void> {\n    try {\n      await this.apiClient.resendVerification(data.email, data.language)\n      sendResponse({ success: true })\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Failed to resend verification'\n      this.logger.error('Resend verification failed:', error)\n      sendResponse({ success: false, error: errorMessage })\n    }\n  }\n\n  /**\n   * Handle AUTH_GET_USER from Popup\n   */\n  async handleGetUser(sendResponse: (response: unknown) => void): Promise<void> {\n    try {\n      await this.apiClient.waitForInitialization()\n      const isAuth = await this.apiClient.isAuthenticated()\n      if (!isAuth) {\n        sendResponse({ success: false, error: 'Not authenticated' })\n        return\n      }\n      const user = this.apiClient.getCachedUser() || (await this.apiClient.getCurrentUser())\n      sendResponse({ success: true, user })\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Failed to get user'\n      this.logger.error('Failed to get user:', error)\n      sendResponse({ success: false, error: errorMessage })\n    }\n  }\n\n  /**\n   * Handle AUTH_GOOGLE_LOGIN from Popup (Fire-and-Forget pattern)\n   *\n   * Uses chrome.identity.launchWebAuthFlow() with prompt=select_account\n   * to always show the Google account picker.\n   *\n   * Result is broadcast via AUTH_GOOGLE_LOGIN_RESULT message to Popup.\n   */\n  async handleGoogleLogin(): Promise<void> {\n    try {\n      this.logger.debug('Starting Google OAuth login flow with launchWebAuthFlow')\n\n      // Step 1: Get Google OAuth token using launchWebAuthFlow (always shows account picker)\n      const googleToken = await this.launchGoogleAuthFlow()\n      if (!googleToken) {\n        this.broadcastGoogleLoginResult(false, undefined, 'Failed to get Google token')\n        return\n      }\n\n      this.logger.debug('Got Google token, exchanging with backend')\n\n      // Step 2: Exchange Google token with backend for JWT\n      await this.apiClient.loginWithGoogle(googleToken)\n\n      // Step 3: Get user info\n      const user = await this.apiClient.getCurrentUser()\n\n      // Step 4: Broadcast success to Popup and all YouTube tabs\n      this.broadcastGoogleLoginResult(true, user)\n      this.broadcastAuthStateChange(true)\n\n      // Step 5: Set Sentry user for error tracking\n      setSentryUser(String(user.id), user.email)\n\n      // Step 6: Save settings from user response (no extra API call needed)\n      if (user.settings) {\n        await this.settingsHandler.saveFromBackend(user.settings)\n      }\n    } catch (error) {\n      const errorMessage = error instanceof Error ? error.message : 'Google login failed'\n      this.logger.error('Google login failed:', error)\n      this.broadcastGoogleLoginResult(false, undefined, errorMessage)\n    }\n  }\n\n  /**\n   * Broadcast Google login result to Popup\n   */\n  private broadcastGoogleLoginResult(success: boolean, user?: unknown, error?: string): void {\n    this.logger.debug(`Broadcasting Google login result: success=${success}`)\n    chrome.runtime.sendMessage({\n      source: MessageSource.BACKGROUND,\n      type: MessageType.AUTH_GOOGLE_LOGIN_RESULT,\n      data: { success, user, error },\n      timestamp: Date.now(),\n    })\n  }\n\n  // Web application OAuth client IDs for launchWebAuthFlow (different from Chrome Extension type in manifest)\n  // This is required because launchWebAuthFlow needs \"Web application\" type, not \"Chrome Extension\" type\n  private static readonly DEV_EXTENSION_ID = 'mdhjpkekidkjoclofebaolcnjjjemgio'\n  private static readonly WEB_APP_CLIENT_ID_DEV =\n    '233013566166-456k7ko0qsib3kbei6gv6ekjjvupappq.apps.googleusercontent.com'\n  private static readonly WEB_APP_CLIENT_ID_PROD =\n    '233013566166-68eqnb21n814ejiccvru8ip3auqjtat6.apps.googleusercontent.com'\n\n  private static getWebAppClientId(): string {\n    const isDev = chrome.runtime.id === AuthMessageHandler.DEV_EXTENSION_ID\n    return isDev\n      ? AuthMessageHandler.WEB_APP_CLIENT_ID_DEV\n      : AuthMessageHandler.WEB_APP_CLIENT_ID_PROD\n  }\n\n  /**\n   * Launch Google OAuth flow using launchWebAuthFlow\n   *\n   * This method always shows the account picker by using prompt=select_account.\n   * Unlike getAuthToken, this gives us full control over the OAuth parameters.\n   *\n   * @returns Google OAuth access token or null if failed/cancelled\n   */\n  private async launchGoogleAuthFlow(): Promise<string | null> {\n    return new Promise((resolve) => {\n      // Get the redirect URL for this extension\n      const redirectUrl = chrome.identity.getRedirectURL()\n      this.logger.debug('Redirect URL:', redirectUrl)\n\n      // Use Web application client ID (not Chrome Extension type from manifest)\n      const clientId = AuthMessageHandler.getWebAppClientId()\n\n      // Build Google OAuth URL with prompt=select_account to force account picker\n      const authUrl = new URL('https://accounts.google.com/o/oauth2/v2/auth')\n      authUrl.searchParams.set('client_id', clientId)\n      authUrl.searchParams.set('redirect_uri', redirectUrl)\n      authUrl.searchParams.set('response_type', 'token')\n      authUrl.searchParams.set('scope', 'openid email profile')\n      authUrl.searchParams.set('prompt', 'select_account') // Force account selection every time\n\n      this.logger.debug('Launching OAuth flow with URL:', authUrl.toString())\n\n      chrome.identity.launchWebAuthFlow(\n        {\n          url: authUrl.toString(),\n          interactive: true,\n        },\n        (responseUrl) => {\n          if (chrome.runtime.lastError) {\n            this.logger.error('launchWebAuthFlow error:', chrome.runtime.lastError.message)\n            resolve(null)\n            return\n          }\n\n          if (!responseUrl) {\n            this.logger.error('No response URL from launchWebAuthFlow')\n            resolve(null)\n            return\n          }\n\n          // Parse access token from the response URL fragment\n          // Format: https://.../#access_token=xxx&token_type=Bearer&expires_in=3600&scope=...\n          const url = new URL(responseUrl)\n          const hashParams = new URLSearchParams(url.hash.substring(1))\n          const accessToken = hashParams.get('access_token')\n\n          if (!accessToken) {\n            this.logger.error('No access token in response URL')\n            resolve(null)\n            return\n          }\n\n          this.logger.debug('Successfully obtained access token from launchWebAuthFlow')\n          resolve(accessToken)\n        },\n      )\n    })\n  }\n\n  /**\n   * Broadcast authentication state change to all YouTube tabs\n   * Content Scripts will update their UI accordingly\n   */\n  broadcastAuthStateChange(authenticated: boolean): void {\n    chrome.tabs.query({ url: '*://*.youtube.com/*' }, (tabs) => {\n      this.logger.debug(`Broadcasting auth state change to ${tabs.length} YouTube tabs`)\n      tabs.forEach((tab) => {\n        if (tab.id) {\n          chrome.tabs.sendMessage(tab.id, {\n            source: MessageSource.BACKGROUND,\n            type: MessageType.AUTH_STATE_CHANGED,\n            data: { authenticated },\n            timestamp: Date.now(),\n          })\n        }\n      })\n    })\n  }\n}\n","/**\n * CollectionMessageHandler - Handles all collection-related messages in Background Service\n *\n * Centralizes collection logic: COLLECTION_LOAD, COLLECTION_CREATE, COLLECTION_ADD,\n * COLLECTION_REMOVE, COLLECTION_CHECK, COLLECTION_GET_LEMMAS\n */\n\nimport { APIClient, VideoCollectionCreateRequest, VideoCollectionResponse } from '../tools/client'\nimport { Logger } from '../tools/logger'\nimport { CollectionInfo, MessageType } from '../types/messages'\nimport { CollectionManager } from './collectionManager'\n\nexport class CollectionMessageHandler {\n  constructor(\n    private apiClient: APIClient,\n    private collectionManager: CollectionManager,\n    private logger: Logger,\n  ) {}\n\n  /**\n   * Check if the message type is collection-related and can be handled by this handler\n   */\n  canHandle(messageType: MessageType): boolean {\n    return [\n      MessageType.COLLECTION_LOAD,\n      MessageType.COLLECTION_CREATE,\n      MessageType.COLLECTION_REMOVE,\n      MessageType.COLLECTION_CHECK,\n      MessageType.COLLECTION_GET_LEMMAS,\n    ].includes(messageType)\n  }\n\n  /**\n   * Handles COLLECTION_LOAD request.\n   * Loads collections for a video and caches them.\n   */\n  async handleLoad(\n    data: { videoViewId: number; sourceLang: string },\n    sendResponse: (response: unknown) => void,\n  ): Promise<void> {\n    try {\n      const collections = await this.collectionManager.loadCollections(\n        data.videoViewId,\n        data.sourceLang,\n      )\n      sendResponse({ collections })\n    } catch (error) {\n      this.logger.error('Failed to load collections:', error)\n      sendResponse({\n        collections: [],\n        error: error instanceof Error ? error.message : 'Failed to load collections',\n      })\n    }\n  }\n\n  /**\n   * Handles COLLECTION_CREATE request.\n   * Calls API to create collection, updates cache, and broadcasts.\n   */\n  async handleCreate(\n    data: { request: VideoCollectionCreateRequest },\n    sendResponse: (response: unknown) => void,\n  ): Promise<void> {\n    try {\n      // Call API to create collection\n      const collection = await this.apiClient.createVideoCollection(data.request)\n      this.logger.info(`Collection created: id=${collection.id}, word=${data.request.word}`)\n\n      // Add to cache\n      const collectionInfo: CollectionInfo = {\n        id: collection.id,\n        word: data.request.word,\n        lemma: data.request.lemma?.toLowerCase() ?? null,\n        segmentBegin: data.request.segment_begin,\n      }\n      this.collectionManager.addCollection(data.request.video_view_id, collectionInfo)\n\n      // Return full collection response for UI update\n      sendResponse({\n        success: true,\n        collection,\n      })\n    } catch (error) {\n      this.logger.error('Failed to create collection:', error)\n      sendResponse({\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to create collection',\n      })\n    }\n  }\n\n  /**\n   * Handles COLLECTION_REMOVE request.\n   * Calls delete API and removes from cache.\n   */\n  async handleRemove(\n    data: { videoViewId: number; collectionId: string },\n    sendResponse: (response: unknown) => void,\n  ): Promise<void> {\n    try {\n      // Call delete API\n      await this.apiClient.deleteVideoCollection(data.collectionId)\n\n      // Remove from cache (videoViewId 0 means search all caches)\n      const videoViewId = data.videoViewId === 0 ? null : data.videoViewId\n      this.collectionManager.removeCollection(videoViewId, data.collectionId)\n\n      sendResponse({ success: true })\n    } catch (error) {\n      this.logger.error('Failed to remove collection:', error)\n      sendResponse({\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to remove collection',\n      })\n    }\n  }\n\n  /**\n   * Handles COLLECTION_CHECK request.\n   * Checks if a word is collected and optionally returns collection ID.\n   */\n  handleCheck(\n    data: { videoViewId: number; word: string; segmentBegin: number; returnId?: boolean },\n    sendResponse: (response: unknown) => void,\n  ): void {\n    const collected = this.collectionManager.isWordCollected(\n      data.videoViewId,\n      data.word,\n      data.segmentBegin,\n    )\n\n    if (data.returnId) {\n      const collectionId = this.collectionManager.getCollectionId(\n        data.videoViewId,\n        data.word,\n        data.segmentBegin,\n      )\n      sendResponse({ collected, collectionId })\n    } else {\n      sendResponse({ collected })\n    }\n  }\n\n  /**\n   * Handles COLLECTION_GET_LEMMAS request.\n   * Returns all collected lemmas for sidebar highlighting.\n   */\n  handleGetLemmas(data: { videoViewId: number }, sendResponse: (response: unknown) => void): void {\n    const lemmasSet = this.collectionManager.getCollectedLemmas(data.videoViewId)\n    sendResponse({ lemmas: Array.from(lemmasSet) })\n  }\n}\n","import { APIClient } from '../tools/client'\nimport { Logger } from '../tools/logger'\nimport {\n  CollectionInfo,\n  CollectionRemovedData,\n  MessageSource,\n  MessageType,\n} from '../types/messages'\n\n/**\n * CollectionManager - Centralized collection state management\n *\n * This singleton class manages all collection data in Background Service:\n * - Caches collections per videoViewId\n * - Provides methods for CRUD operations\n * - Broadcasts changes to all subscribers (Content Scripts + Popup)\n *\n * Benefits:\n * - Single source of truth for collection state\n * - Automatic broadcast on data changes\n * - Multi-tab synchronization support\n */\nexport class CollectionManager {\n  private static instance: CollectionManager | null = null\n\n  private logger = new Logger('[CollectionManager]')\n  private apiClient: APIClient\n\n  // videoViewId → (cacheKey → CollectionInfo)\n  private cache: Map<number, Map<string, CollectionInfo>> = new Map()\n\n  private constructor(apiClient: APIClient) {\n    this.apiClient = apiClient\n  }\n\n  /**\n   * Get singleton instance\n   */\n  static getInstance(apiClient: APIClient): CollectionManager {\n    if (!CollectionManager.instance) {\n      CollectionManager.instance = new CollectionManager(apiClient)\n    }\n    return CollectionManager.instance\n  }\n\n  /**\n   * Load collections for a specific video.\n   * Caches the result and broadcasts COLLECTIONS_LOADED event.\n   *\n   * @param videoViewId - Video view ID\n   * @param sourceLang - Source language code\n   * @returns Array of CollectionInfo\n   */\n  async loadCollections(videoViewId: number, sourceLang: string): Promise<CollectionInfo[]> {\n    this.logger.debug(\n      `Loading collections for videoViewId=${videoViewId}, sourceLang=${sourceLang}`,\n    )\n\n    try {\n      const response = await this.apiClient.getVideoCollections({\n        video_view_id: videoViewId,\n        source_language: sourceLang,\n        limit: 1000, // Load all collections for this video\n      })\n\n      const videoCache = new Map<string, CollectionInfo>()\n      const collections: CollectionInfo[] = []\n\n      for (const item of response.items) {\n        const info: CollectionInfo = {\n          id: item.id,\n          word: item.word,\n          lemma: item.lemma ? item.lemma.toLowerCase() : null,\n          segmentBegin: item.segment_begin,\n        }\n        const key = this.getCacheKey(item.word, item.segment_begin)\n        videoCache.set(key, info)\n        collections.push(info)\n      }\n\n      this.cache.set(videoViewId, videoCache)\n      this.logger.info(`Loaded ${collections.length} collections for videoViewId=${videoViewId}`)\n\n      return collections\n    } catch (error) {\n      this.logger.error(`Failed to load collections for videoViewId=${videoViewId}:`, error)\n      throw error\n    }\n  }\n\n  /**\n   * Add a collection to cache (called after successful API creation).\n   * Broadcasts COLLECTION_ADDED event.\n   *\n   * @param videoViewId - Video view ID\n   * @param collection - Collection info to add\n   */\n  addCollection(videoViewId: number, collection: CollectionInfo): void {\n    let videoCache = this.cache.get(videoViewId)\n    if (!videoCache) {\n      videoCache = new Map()\n      this.cache.set(videoViewId, videoCache)\n    }\n\n    const key = this.getCacheKey(collection.word, collection.segmentBegin)\n    videoCache.set(key, collection)\n\n    this.logger.debug(\n      `Added collection: videoViewId=${videoViewId}, word=${collection.word}, id=${collection.id}`,\n    )\n\n    // Broadcast to all subscribers\n    this.broadcast(MessageType.COLLECTION_ADDED, { videoViewId, collection })\n  }\n\n  /**\n   * Remove a collection from cache (called after successful API deletion).\n   * Broadcasts COLLECTION_REMOVED event.\n   *\n   * @param videoViewId - Video view ID (optional, will search all caches if null)\n   * @param collectionId - Collection UUID to remove\n   */\n  removeCollection(videoViewId: number | null, collectionId: string): void {\n    // Determine which caches to search\n    let cachesToSearch: Array<[number, Map<string, CollectionInfo>]>\n\n    if (videoViewId !== null) {\n      const videoCache = this.cache.get(videoViewId)\n      if (!videoCache) {\n        this.logger.warn(`No cache found for videoViewId=${videoViewId}`)\n        return\n      }\n      cachesToSearch = [[videoViewId, videoCache]]\n    } else {\n      cachesToSearch = Array.from(this.cache.entries())\n    }\n\n    // Search and remove\n    for (const [vvId, videoCache] of cachesToSearch) {\n      for (const [key, info] of videoCache.entries()) {\n        if (info.id === collectionId) {\n          videoCache.delete(key)\n          this.logger.debug(`Removed collection: videoViewId=${vvId}, collectionId=${collectionId}`)\n\n          // Broadcast\n          const data: CollectionRemovedData = {\n            videoViewId: vvId,\n            collectionId,\n            word: info.word,\n            lemma: info.lemma,\n          }\n          this.broadcast(MessageType.COLLECTION_REMOVED, data)\n          return\n        }\n      }\n    }\n\n    const scope = videoViewId !== null ? `videoViewId=${videoViewId}` : 'all caches'\n    this.logger.warn(`Collection not found in ${scope}: collectionId=${collectionId}`)\n  }\n\n  /**\n   * Check if a word is collected for a specific video.\n   *\n   * @param videoViewId - Video view ID\n   * @param word - Word to check\n   * @param segmentBegin - Segment start time (ms)\n   * @returns true if collected, false otherwise\n   */\n  isWordCollected(videoViewId: number, word: string, segmentBegin: number): boolean {\n    const videoCache = this.cache.get(videoViewId)\n    if (!videoCache) return false\n\n    const key = this.getCacheKey(word, segmentBegin)\n    return videoCache.has(key)\n  }\n\n  /**\n   * Get collection ID for a word (used for unfavorite).\n   *\n   * @param videoViewId - Video view ID\n   * @param word - Word to look up\n   * @param segmentBegin - Segment start time (ms)\n   * @returns Collection ID or null if not found\n   */\n  getCollectionId(videoViewId: number, word: string, segmentBegin: number): string | null {\n    const videoCache = this.cache.get(videoViewId)\n    if (!videoCache) return null\n\n    const key = this.getCacheKey(word, segmentBegin)\n    return videoCache.get(key)?.id ?? null\n  }\n\n  /**\n   * Get all collected lemmas for a video (used for sidebar highlighting).\n   *\n   * @param videoViewId - Video view ID\n   * @returns Set of lowercase lemmas\n   */\n  getCollectedLemmas(videoViewId: number): Set<string> {\n    const lemmas = new Set<string>()\n    const videoCache = this.cache.get(videoViewId)\n    if (!videoCache) return lemmas\n\n    for (const info of videoCache.values()) {\n      if (info.lemma) {\n        lemmas.add(info.lemma)\n      }\n    }\n    return lemmas\n  }\n\n  /**\n   * Clear cache for a specific video (e.g., when video changes).\n   *\n   * @param videoViewId - Video view ID\n   */\n  clearCache(videoViewId: number): void {\n    this.cache.delete(videoViewId)\n    this.logger.debug(`Cleared cache for videoViewId=${videoViewId}`)\n  }\n\n  /**\n   * Generate cache key from word and segment begin time.\n   */\n  private getCacheKey(word: string, segmentBegin: number): string {\n    return `${word.toLowerCase()}:${segmentBegin}`\n  }\n\n  /**\n   * Broadcast message to all YouTube tabs and Popup.\n   */\n  private broadcast(type: MessageType, data: any): void {\n    // Broadcast to all YouTube tabs\n    chrome.tabs.query({ url: '*://*.youtube.com/*' }, (tabs) => {\n      for (const tab of tabs) {\n        if (tab.id) {\n          chrome.tabs\n            .sendMessage(tab.id, {\n              source: MessageSource.BACKGROUND,\n              type,\n              data,\n              timestamp: Date.now(),\n            })\n            .catch(() => {\n              // Tab may not have Content Script, ignore error\n            })\n        }\n      }\n    })\n\n    // Also send to Popup (if open)\n    chrome.runtime\n      .sendMessage({\n        source: MessageSource.BACKGROUND,\n        type,\n        data,\n        timestamp: Date.now(),\n      })\n      .catch(() => {\n        // Popup may not be open, ignore error\n      })\n  }\n}\n","/**\n * SettingsHandler - Handles all settings-related messages in Background Service\n *\n * Centralizes settings logic: SETTINGS_LOAD, SETTINGS_SAVE\n * Also handles broadcasting settings changes to Content Scripts.\n *\n * Backend Sync (2025-12-08):\n * - When user is authenticated, settings are synced with backend API\n * - Backend is the source of truth for authenticated users\n * - Local storage (chrome.storage.sync) serves as cache and fallback for offline\n * - Key naming: backend uses snake_case (native_language), local uses camelCase (nativeLanguage)\n */\n\nimport { APIClient, UserSettingsResponse } from '../tools/client'\nimport { Logger } from '../tools/logger'\nimport {\n  MessageSource,\n  MessageType,\n  SettingsChangedData,\n  SettingsResponse,\n  UserSettings,\n} from '../types/messages'\n\n// Default settings when none are stored\nconst DEFAULT_SETTINGS: UserSettings = {\n  nativeLanguage: 'en',\n  targetLanguage: 'es',\n  interfaceLanguage: 'en',\n}\n\n/**\n * Convert backend settings (snake_case) to local settings (camelCase)\n */\nfunction backendToLocal(backend: UserSettingsResponse): UserSettings {\n  return {\n    nativeLanguage: backend.native_language,\n    targetLanguage: backend.target_language,\n    interfaceLanguage: backend.interface_language,\n  }\n}\n\n/**\n * Convert local settings (camelCase) to backend format (snake_case)\n */\nfunction localToBackend(local: Partial<UserSettings>): {\n  native_language?: string\n  target_language?: string\n  interface_language?: string\n} {\n  const result: {\n    native_language?: string\n    target_language?: string\n    interface_language?: string\n  } = {}\n  if (local.nativeLanguage !== undefined) result.native_language = local.nativeLanguage\n  if (local.targetLanguage !== undefined) result.target_language = local.targetLanguage\n  if (local.interfaceLanguage !== undefined) result.interface_language = local.interfaceLanguage\n  return result\n}\n\nexport class SettingsHandler {\n  constructor(private logger: Logger) {}\n\n  /**\n   * Check if the message type is settings-related and can be handled by this handler\n   */\n  canHandle(messageType: MessageType): boolean {\n    return [MessageType.SETTINGS_LOAD, MessageType.SETTINGS_SAVE].includes(messageType)\n  }\n\n  /**\n   * Handle SETTINGS_LOAD from Popup or Content Script\n   *\n   * Always reads from local storage (chrome.storage.sync).\n   * Backend sync happens only on login success via saveFromBackend().\n   *\n   * TODO: Add expiration-based sync to handle multi-device scenarios.\n   *       When settings are older than X hours, fetch from backend on load.\n   */\n  async handleLoad(sendResponse: (response: SettingsResponse) => void): Promise<void> {\n    try {\n      const stored = await chrome.storage.sync.get([\n        'nativeLanguage',\n        'targetLanguage',\n        'interfaceLanguage',\n      ])\n\n      const settings: UserSettings = {\n        nativeLanguage: stored.nativeLanguage || DEFAULT_SETTINGS.nativeLanguage,\n        targetLanguage: stored.targetLanguage || DEFAULT_SETTINGS.targetLanguage,\n        interfaceLanguage: stored.interfaceLanguage || DEFAULT_SETTINGS.interfaceLanguage,\n      }\n\n      this.logger.debug('Loaded settings from local storage:', settings)\n      sendResponse({ success: true, settings })\n    } catch (error) {\n      this.logger.error('Failed to load settings:', error)\n      sendResponse({\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to load settings',\n      })\n    }\n  }\n\n  /**\n   * Save settings from backend response to local storage\n   *\n   * Called by AuthMessageHandler after successful login/registration.\n   * Uses settings already fetched from getCurrentUser(), avoiding extra API call.\n   */\n  async saveFromBackend(backendSettings: UserSettingsResponse): Promise<void> {\n    const settings = backendToLocal(backendSettings)\n\n    await chrome.storage.sync.set({\n      nativeLanguage: settings.nativeLanguage,\n      targetLanguage: settings.targetLanguage,\n      interfaceLanguage: settings.interfaceLanguage,\n    })\n\n    this.logger.debug('Saved settings from user response:', settings)\n\n    // Broadcast to all YouTube tabs so they get the latest settings\n    this.broadcastSettingsChange(settings, [\n      'nativeLanguage',\n      'targetLanguage',\n      'interfaceLanguage',\n    ])\n  }\n\n  /**\n   * Handle SETTINGS_SAVE from Popup\n   *\n   * Flow:\n   * 1. Always save to local storage (chrome.storage.sync)\n   * 2. If authenticated, also sync to backend API\n   * 3. Backend failures are logged but don't block the save operation\n   * 4. Broadcast changes to all YouTube tabs\n   */\n  async handleSave(\n    data: { settings: Partial<UserSettings> },\n    sendResponse: (response: SettingsResponse) => void,\n  ): Promise<void> {\n    try {\n      const { settings: newSettings } = data\n\n      // Load current settings to detect which keys changed\n      const stored = await chrome.storage.sync.get([\n        'nativeLanguage',\n        'targetLanguage',\n        'interfaceLanguage',\n      ])\n\n      const currentSettings: UserSettings = {\n        nativeLanguage: stored.nativeLanguage || DEFAULT_SETTINGS.nativeLanguage,\n        targetLanguage: stored.targetLanguage || DEFAULT_SETTINGS.targetLanguage,\n        interfaceLanguage: stored.interfaceLanguage || DEFAULT_SETTINGS.interfaceLanguage,\n      }\n\n      // Detect which keys changed\n      const changedKeys: (keyof UserSettings)[] = []\n      for (const key of Object.keys(newSettings) as (keyof UserSettings)[]) {\n        if (newSettings[key] !== undefined && newSettings[key] !== currentSettings[key]) {\n          changedKeys.push(key)\n        }\n      }\n\n      // Merge with new settings\n      const updatedSettings: UserSettings = {\n        ...currentSettings,\n        ...newSettings,\n      }\n\n      // Save to local storage first (immediate, reliable)\n      await chrome.storage.sync.set({\n        nativeLanguage: updatedSettings.nativeLanguage,\n        targetLanguage: updatedSettings.targetLanguage,\n        interfaceLanguage: updatedSettings.interfaceLanguage,\n      })\n\n      this.logger.debug('Saved settings to local:', updatedSettings, 'Changed keys:', changedKeys)\n\n      // If authenticated, also sync to backend (fire-and-forget, don't block response)\n      const apiClient = APIClient.getInstance()\n      await apiClient.waitForInitialization()\n      const isAuthenticated = await apiClient.isAuthenticated()\n\n      if (isAuthenticated && changedKeys.length > 0) {\n        // Convert to backend format (only changed keys)\n        const backendUpdate = localToBackend(newSettings)\n\n        // Fire-and-forget: don't wait for backend response\n        apiClient.updateUserSettings(backendUpdate).then(\n          () => {\n            this.logger.debug('Settings synced to backend successfully')\n          },\n          (error) => {\n            this.logger.warn('Failed to sync settings to backend:', error)\n            // Don't fail the operation - local storage is already saved\n          },\n        )\n      }\n\n      // Send response immediately after local save\n      sendResponse({ success: true, settings: updatedSettings })\n\n      // Broadcast changes to all YouTube tabs if any keys changed\n      if (changedKeys.length > 0) {\n        this.broadcastSettingsChange(updatedSettings, changedKeys)\n      }\n    } catch (error) {\n      this.logger.error('Failed to save settings:', error)\n      sendResponse({\n        success: false,\n        error: error instanceof Error ? error.message : 'Failed to save settings',\n      })\n    }\n  }\n\n  /**\n   * Broadcast settings change to all YouTube tabs\n   * Content Scripts will update their UI accordingly (e.g., reload i18n, refresh MokiControl menu)\n   */\n  broadcastSettingsChange(settings: UserSettings, changedKeys: (keyof UserSettings)[]): void {\n    chrome.tabs.query({ url: '*://*.youtube.com/*' }, (tabs) => {\n      this.logger.debug(\n        `Broadcasting settings change to ${tabs.length} YouTube tabs. Changed: ${changedKeys.join(', ')}`,\n      )\n\n      const data: SettingsChangedData = { settings, changedKeys }\n\n      tabs.forEach((tab) => {\n        if (tab.id) {\n          chrome.tabs.sendMessage(tab.id, {\n            source: MessageSource.BACKGROUND,\n            type: MessageType.SETTINGS_CHANGED,\n            data,\n            timestamp: Date.now(),\n          })\n        }\n      })\n    })\n  }\n}\n","import { Logger } from '../tools/logger'\nimport { APIClient } from '../tools/client'\n\n/**\n * External Message Types - for communication with web pages\n */\nexport enum ExternalMessageType {\n  PING = 'PING',\n  OPEN_POPUP = 'OPEN_POPUP',\n}\n\n/**\n * PING response - includes user ID for account verification\n */\ninterface PingResponse {\n  version: string\n  userId: number | null // null if not logged in\n}\n\n/**\n * Handles messages from external web pages (via externally_connectable)\n */\nexport class ExternalMessageHandler {\n  constructor(\n    private apiClient: APIClient,\n    private logger: Logger,\n  ) {}\n\n  /**\n   * Sets up the external message listener\n   */\n  setupListener(): void {\n    chrome.runtime.onMessageExternal.addListener(\n      (message: { type: string; [key: string]: unknown }, sender, sendResponse) => {\n        this.logger.debug('External message received:', message.type, 'from:', sender.origin)\n\n        switch (message.type) {\n          case ExternalMessageType.PING:\n            this.handlePing(sendResponse)\n            return true // async response\n\n          case ExternalMessageType.OPEN_POPUP:\n            this.handleOpenPopup(message as { collectionIds?: number[] }, sendResponse)\n            return true // async response\n\n          default:\n            this.logger.warn('Unknown external message type:', message.type)\n            sendResponse({ error: 'Unknown message type' })\n            return false\n        }\n      },\n    )\n  }\n\n  /**\n   * Handle PING - returns extension version and user ID\n   */\n  private async handlePing(sendResponse: (response: PingResponse) => void): Promise<void> {\n    try {\n      const version = chrome.runtime.getManifest().version\n      let userId: number | null = null\n\n      // Get current user ID if authenticated\n      const isAuth = await this.apiClient.isAuthenticated()\n      if (isAuth) {\n        try {\n          const user = await this.apiClient.getCurrentUser()\n          userId = user?.id || null\n        } catch {\n          // User not available, keep userId as null\n        }\n      }\n\n      this.logger.debug('PING response:', { version, userId })\n      sendResponse({ version, userId })\n    } catch (error) {\n      this.logger.error('PING handler error:', error)\n      sendResponse({ version: chrome.runtime.getManifest().version, userId: null })\n    }\n  }\n\n  /**\n   * Handle OPEN_POPUP - opens the extension popup\n   * If collectionIds are provided, saves them for the export flow\n   */\n  private async handleOpenPopup(\n    message: { collectionIds?: number[] },\n    sendResponse: (response: { success: boolean; error?: string }) => void,\n  ): Promise<void> {\n    try {\n      // If collectionIds are provided, save them for the export flow\n      if (message.collectionIds && message.collectionIds.length > 0) {\n        await chrome.storage.local.set({\n          pendingExport: {\n            collectionIds: message.collectionIds,\n            timestamp: Date.now(),\n          },\n        })\n        this.logger.debug('Saved pending export:', message.collectionIds.length, 'items')\n      }\n\n      await chrome.action.openPopup()\n      this.logger.debug('Popup opened successfully')\n      sendResponse({ success: true })\n    } catch (error) {\n      this.logger.error('Failed to open popup:', error)\n      // Fallback: open popup in new tab\n      try {\n        await chrome.tabs.create({\n          url: chrome.runtime.getURL('popup.html'),\n        })\n        sendResponse({ success: true })\n      } catch (fallbackError) {\n        sendResponse({\n          success: false,\n          error: fallbackError instanceof Error ? fallbackError.message : 'Failed to open popup',\n        })\n      }\n    }\n  }\n}\n","import { Logger } from '../tools/logger'\nimport { Message, MessageSource, MessageType } from '../types/messages'\nimport { APIClient } from '../tools/client'\nimport { AuthMessageHandler } from './authHandler'\nimport { CollectionMessageHandler } from './collectionHandler'\nimport { CollectionManager } from './collectionManager'\nimport { SettingsHandler } from './settingsHandler'\nimport { ExternalMessageHandler } from './externalMessageHandler'\n\n/**\n * Stateless Background Service - API Proxy Pattern\n *\n * This service acts as a pure API proxy between Content Scripts and the backend.\n * It does NOT store any subtitle data or manage task queues.\n *\n * Key responsibilities:\n * - Forward API requests from Content Scripts to backend\n * - Handle authentication (login, logout, token management)\n * - Broadcast language change events to all YouTube tabs\n *\n * Data ownership:\n * - Content Script owns subtitle data and manages task queues\n * - Each tab has independent TranslationService instance\n * - Background is stateless and supports multiple tabs\n */\nclass BackgroundService {\n  private logger = new Logger('[Background]')\n  private nativeLng: string = 'zh-CN'\n  private apiClient: APIClient\n  private authHandler: AuthMessageHandler\n  private collectionHandler: CollectionMessageHandler\n  private settingsHandler: SettingsHandler\n  private externalMessageHandler: ExternalMessageHandler\n\n  constructor() {\n    this.apiClient = APIClient.getInstance()\n    this.settingsHandler = new SettingsHandler(this.logger)\n    this.authHandler = new AuthMessageHandler(this.apiClient, this.logger, this.settingsHandler)\n    const collectionManager = CollectionManager.getInstance(this.apiClient)\n    this.collectionHandler = new CollectionMessageHandler(\n      this.apiClient,\n      collectionManager,\n      this.logger,\n    )\n    this.externalMessageHandler = new ExternalMessageHandler(this.apiClient, this.logger)\n    this.setupMessageListeners()\n    this.externalMessageHandler.setupListener()\n\n    // Initialize Sentry user if already logged in\n    this.authHandler.initSentryUser()\n  }\n\n  /**\n   * Sets up Chrome runtime message listeners\n   */\n  private setupMessageListeners(): void {\n    chrome.runtime.onMessage.addListener((message: Message, sender, sendResponse) => {\n      if (message.source === MessageSource.CONTENT_SCRIPT) {\n        return this.handleContentScriptMessage(message, sender, sendResponse)\n      } else if (message.source === MessageSource.POPUP) {\n        return this.handlePopupMessage(message, sender, sendResponse)\n      } else {\n        this.logger.warn(`Unknown message source: ${message.source}`)\n        return false\n      }\n    })\n  }\n\n  /**\n   * Handles messages from Content Scripts\n   */\n  private handleContentScriptMessage(\n    message: Message,\n    _sender: chrome.runtime.MessageSender,\n    sendResponse: (response?: any) => void,\n  ): boolean {\n    switch (message.type) {\n      // ============================================\n      // Stateless API Proxy: Request-Response Pattern\n      // ============================================\n      case MessageType.TRANSLATE_REQUEST:\n        this.handleTranslateRequest(message.data, sendResponse)\n        return true // Keep channel open for async response\n\n      case MessageType.PHRASE_EXTRACT_REQUEST:\n        this.handlePhraseExtractRequest(message.data, sendResponse)\n        return true // Keep channel open for async response\n\n      // ============================================\n      // Collection Management\n      // ============================================\n      case MessageType.COLLECTION_LOAD:\n        this.collectionHandler.handleLoad(message.data, sendResponse)\n        return true\n\n      case MessageType.COLLECTION_CREATE:\n        this.collectionHandler.handleCreate(message.data, sendResponse)\n        return true\n\n      case MessageType.COLLECTION_REMOVE:\n        this.collectionHandler.handleRemove(message.data, sendResponse)\n        return true\n\n      case MessageType.COLLECTION_CHECK:\n        this.collectionHandler.handleCheck(message.data, sendResponse)\n        return true\n\n      case MessageType.COLLECTION_GET_LEMMAS:\n        this.collectionHandler.handleGetLemmas(message.data, sendResponse)\n        return true\n\n      // ============================================\n      // Authentication\n      // ============================================\n      case MessageType.CHECK_AUTH:\n        this.authHandler.handleContentScriptCheckAuth(sendResponse)\n        return true\n\n      case MessageType.OPEN_POPUP:\n        this.openPopup()\n        break\n\n      // ============================================\n      // Generic API Call (for other API methods)\n      // ============================================\n      case MessageType.API_CALL:\n        this.handleAPICall(message.data, sendResponse)\n        return true\n\n      default:\n        this.logger.warn(`Unknown content script message type: ${message.type}`)\n        break\n    }\n    return false\n  }\n\n  /**\n   * Handles messages from Popup\n   */\n  private handlePopupMessage(\n    message: Message,\n    _sender: chrome.runtime.MessageSender,\n    sendResponse: (response?: any) => void,\n  ): boolean {\n    switch (message.type) {\n      // ============================================\n      // Authentication\n      // ============================================\n      case MessageType.AUTH_LOGIN:\n        this.authHandler.handleLogin(message.data, sendResponse)\n        return true\n\n      case MessageType.AUTH_LOGOUT:\n        this.authHandler.handleLogout(sendResponse)\n        return true\n\n      case MessageType.AUTH_REGISTER:\n        this.authHandler.handleRegister(message.data, sendResponse)\n        return true\n\n      case MessageType.AUTH_GET_USER:\n        this.authHandler.handleGetUser(sendResponse)\n        return true\n\n      case MessageType.CHECK_AUTH:\n        this.authHandler.handlePopupCheckAuth(sendResponse)\n        return true\n\n      case MessageType.AUTH_GOOGLE_LOGIN:\n        // Fire-and-forget: result is broadcast via AUTH_GOOGLE_LOGIN_RESULT\n        this.authHandler.handleGoogleLogin()\n        return false // No async response needed\n\n      case MessageType.AUTH_VERIFY_EMAIL:\n        this.authHandler.handleVerifyEmail(message.data, sendResponse)\n        return true\n\n      case MessageType.AUTH_RESEND_VERIFICATION:\n        this.authHandler.handleResendVerification(message.data, sendResponse)\n        return true\n\n      // ============================================\n      // Settings Management\n      // ============================================\n      case MessageType.SETTINGS_LOAD:\n        this.settingsHandler.handleLoad(sendResponse)\n        return true\n\n      case MessageType.SETTINGS_SAVE:\n        this.settingsHandler.handleSave(message.data, sendResponse)\n        return true\n\n      // ============================================\n      // Language Change (broadcast to all tabs)\n      // ============================================\n      case MessageType.NATIVE_LANGUAGE_CHANGE:\n        this.handleNativeLanguageChange(message.data.nativeLng)\n        break\n\n      // ============================================\n      // Debug Page (stateless - no subtitle data)\n      // ============================================\n      case MessageType.GET_SUBTITLE_DATA:\n        // Background no longer stores subtitle data\n        // Debug page should get data from Content Script directly\n        sendResponse({\n          source: MessageSource.BACKGROUND,\n          type: MessageType.GET_SUBTITLE_DATA_RESPONSE,\n          data: {\n            subtitleData: null,\n            message: 'Background is stateless. Subtitle data is managed by Content Script.',\n          },\n          timestamp: Date.now(),\n        })\n        break\n\n      // ============================================\n      // Collection Management (for Popup delete)\n      // ============================================\n      case MessageType.COLLECTION_REMOVE:\n        this.collectionHandler.handleRemove(message.data, sendResponse)\n        return true\n\n      // ============================================\n      // Generic API Call\n      // ============================================\n      case MessageType.API_CALL:\n        this.handleAPICall(message.data, sendResponse)\n        return true\n\n      default:\n        this.logger.warn(`Unknown popup message type: ${message.type}`)\n    }\n    return false\n  }\n\n  /**\n   * Handles translation requests from Content Script.\n   * Pure API proxy - no state management.\n   */\n  private async handleTranslateRequest(\n    data: { segments: string[]; sourceLng: string; targetLng: string },\n    sendResponse: (response: any) => void,\n  ): Promise<void> {\n    const { segments, sourceLng, targetLng } = data\n\n    try {\n      const response = await this.apiClient.translate({\n        segments,\n        source_lng: sourceLng,\n        target_lng: targetLng,\n      })\n\n      if (response.segments.length !== segments.length) {\n        throw new Error(\n          `Translation count mismatch: expected ${segments.length}, got ${response.segments.length}`,\n        )\n      }\n\n      sendResponse({\n        success: true,\n        segments: response.segments,\n      })\n    } catch (error) {\n      this.logger.error('Translation request failed:', error)\n      sendResponse({\n        success: false,\n        error: error instanceof Error ? error.message : 'Translation failed',\n      })\n    }\n  }\n\n  /**\n   * Handles phrase extraction requests from Content Script.\n   * Pure API proxy - no state management.\n   */\n  private async handlePhraseExtractRequest(\n    data: { texts: string[]; language: string; nativeLng: string },\n    sendResponse: (response: any) => void,\n  ): Promise<void> {\n    const { texts, language, nativeLng } = data\n\n    try {\n      const response = await this.apiClient.extractPhrases({\n        texts,\n        language,\n        native_lng: nativeLng,\n      })\n\n      sendResponse({\n        success: true,\n        phrases: response.phrases,\n      })\n    } catch (error) {\n      this.logger.error('Phrase extraction request failed:', error)\n      sendResponse({\n        success: false,\n        error: error instanceof Error ? error.message : 'Phrase extraction failed',\n      })\n    }\n  }\n\n  /**\n   * Opens the extension popup.\n   */\n  private openPopup(): void {\n    ;(async () => {\n      try {\n        await chrome.action.openPopup()\n        this.logger.debug('Popup opened successfully')\n      } catch (error) {\n        this.logger.error('Failed to open popup:', error)\n        // Fallback: open popup in new tab\n        chrome.tabs.create({\n          url: chrome.runtime.getURL('popup.html'),\n        })\n      }\n    })()\n  }\n\n  /**\n   * Handles native language change from Popup.\n   * Broadcasts to all YouTube tabs.\n   */\n  private handleNativeLanguageChange(newNativeLng: string): void {\n    if (this.nativeLng === newNativeLng) {\n      return\n    }\n\n    this.logger.debug(`Native language changed: ${this.nativeLng} → ${newNativeLng}`)\n    this.nativeLng = newNativeLng\n\n    // Broadcast to all YouTube tabs\n    chrome.tabs.query({ url: '*://*.youtube.com/*' }, (tabs) => {\n      this.logger.debug(`Broadcasting language change to ${tabs.length} YouTube tabs`)\n      tabs.forEach((tab) => {\n        if (tab.id) {\n          chrome.tabs.sendMessage(tab.id, {\n            source: MessageSource.BACKGROUND,\n            type: MessageType.NATIVE_LANGUAGE_CHANGE,\n            data: { nativeLng: newNativeLng },\n            timestamp: Date.now(),\n          })\n        }\n      })\n    })\n  }\n\n  /**\n   * Handles generic API calls.\n   * Forwards method calls to APIClient.\n   */\n  private async handleAPICall(\n    data: { method: string; args: unknown[] },\n    sendResponse: (response: any) => void,\n  ): Promise<void> {\n    const { method, args } = data\n\n    try {\n      await this.apiClient.waitForInitialization()\n\n      const apiMethod = (this.apiClient as any)[method]\n      if (typeof apiMethod !== 'function') {\n        throw new Error(`Unknown API method: ${method}`)\n      }\n\n      const result = await apiMethod.apply(this.apiClient, args)\n\n      sendResponse({\n        success: true,\n        data: result,\n      })\n    } catch (error) {\n      this.logger.error(`API call '${method}' failed:`, error)\n      sendResponse({\n        success: false,\n        error: error instanceof Error ? error.message : 'API call failed',\n      })\n    }\n  }\n}\n\n/**\n * Initialize the background service\n */\nnew BackgroundService()\n"],"names":["setSentryUser","clearSentryUser","ExternalMessageType"],"mappings":"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"}